// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"encoding/json"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const addIntentFees = `-- name: AddIntentFees :exec
INSERT INTO intent_fees (
  offchain_input_fee_program,
  onchain_input_fee_program,
  offchain_output_fee_program,
  onchain_output_fee_program
)
SELECT
    -- if all fee programs are empty, set them all to empty, else use provided, but if provided is empty fetch and use latest for that fee program.
    -- if no rows exist in intent_fees, and a specific fee program is passed in as empty, default to empty string. 
  CASE 
    WHEN ($1 = '' AND $2 = '' AND $3 = '' AND $4 = '') THEN ''
    WHEN $1 <> '' THEN $1
    ELSE COALESCE((SELECT offchain_input_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END,
  CASE
    WHEN ($1 = '' AND $2 = '' AND $3 = '' AND $4 = '') THEN ''
    WHEN $2 <> '' THEN $2
    ELSE COALESCE((SELECT onchain_input_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END,
  CASE
    WHEN ($1 = '' AND $2 = '' AND $3 = '' AND $4 = '') THEN ''
    WHEN $3 <> '' THEN $3
    ELSE COALESCE((SELECT offchain_output_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END,
  CASE
    WHEN ($1 = '' AND $2 = '' AND $3 = '' AND $4 = '') THEN ''
    WHEN $4 <> '' THEN $4
    ELSE COALESCE((SELECT onchain_output_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END
`

type AddIntentFeesParams struct {
	OffchainInputFeeProgram  interface{}
	OnchainInputFeeProgram   interface{}
	OffchainOutputFeeProgram interface{}
	OnchainOutputFeeProgram  interface{}
}

func (q *Queries) AddIntentFees(ctx context.Context, arg AddIntentFeesParams) error {
	_, err := q.db.ExecContext(ctx, addIntentFees,
		arg.OffchainInputFeeProgram,
		arg.OnchainInputFeeProgram,
		arg.OffchainOutputFeeProgram,
		arg.OnchainOutputFeeProgram,
	)
	return err
}

const bulkInsertSweptMarkers = `-- name: BulkInsertSweptMarkers :exec
INSERT INTO swept_marker (marker_id, swept_at)
SELECT unnest($1::text[]), $2
ON CONFLICT(marker_id) DO NOTHING
`

type BulkInsertSweptMarkersParams struct {
	MarkerIds []string
	SweptAt   int64
}

func (q *Queries) BulkInsertSweptMarkers(ctx context.Context, arg BulkInsertSweptMarkersParams) error {
	_, err := q.db.ExecContext(ctx, bulkInsertSweptMarkers, pq.Array(arg.MarkerIds), arg.SweptAt)
	return err
}

const clearIntentFees = `-- name: ClearIntentFees :exec
INSERT INTO intent_fees (
  offchain_input_fee_program,
  onchain_input_fee_program,
  offchain_output_fee_program,
  onchain_output_fee_program
)
VALUES ('', '', '', '')
`

func (q *Queries) ClearIntentFees(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearIntentFees)
	return err
}

const clearScheduledSession = `-- name: ClearScheduledSession :exec
DELETE FROM scheduled_session
`

func (q *Queries) ClearScheduledSession(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearScheduledSession)
	return err
}

const countUnsweptVtxosByMarkerId = `-- name: CountUnsweptVtxosByMarkerId :one
SELECT COUNT(*) FROM vtxo_vw WHERE markers @> jsonb_build_array($1::TEXT) AND swept = false
`

// Count VTXOs whose markers JSONB array contains the given marker_id and are not swept
func (q *Queries) CountUnsweptVtxosByMarkerId(ctx context.Context, markerID string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUnsweptVtxosByMarkerId, markerID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getDescendantMarkerIds = `-- name: GetDescendantMarkerIds :many
WITH RECURSIVE descendant_markers(id) AS (
    -- Base case: the marker being swept
    SELECT marker.id FROM marker WHERE marker.id = $1
    UNION ALL
    -- Recursive case: find markers whose parent_markers jsonb array contains any descendant
    SELECT m.id FROM marker m
    INNER JOIN descendant_markers dm ON (
        m.parent_markers @> jsonb_build_array(dm.id)
    )
)
SELECT descendant_markers.id AS marker_id FROM descendant_markers
WHERE descendant_markers.id NOT IN (SELECT sm.marker_id FROM swept_marker sm)
`

// Recursively get a marker and all its descendants (markers whose parent_markers contain it)
func (q *Queries) GetDescendantMarkerIds(ctx context.Context, rootMarkerID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getDescendantMarkerIds, rootMarkerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var marker_id string
		if err := rows.Scan(&marker_id); err != nil {
			return nil, err
		}
		items = append(items, marker_id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertAsset = `-- name: InsertAsset :exec
INSERT INTO asset (id, is_immutable, metadata_hash, metadata, control_asset_id)
VALUES ($1, $2, $3, $4, $5)
`

type InsertAssetParams struct {
	ID             string
	IsImmutable    bool
	MetadataHash   sql.NullString
	Metadata       sql.NullString
	ControlAssetID sql.NullString
}

func (q *Queries) InsertAsset(ctx context.Context, arg InsertAssetParams) error {
	_, err := q.db.ExecContext(ctx, insertAsset,
		arg.ID,
		arg.IsImmutable,
		arg.MetadataHash,
		arg.Metadata,
		arg.ControlAssetID,
	)
	return err
}

const insertSweptMarker = `-- name: InsertSweptMarker :exec
INSERT INTO swept_marker (marker_id, swept_at)
VALUES ($1, $2)
ON CONFLICT(marker_id) DO NOTHING
`

type InsertSweptMarkerParams struct {
	MarkerID string
	SweptAt  int64
}

func (q *Queries) InsertSweptMarker(ctx context.Context, arg InsertSweptMarkerParams) error {
	_, err := q.db.ExecContext(ctx, insertSweptMarker, arg.MarkerID, arg.SweptAt)
	return err
}

const insertVtxoAssetProjection = `-- name: InsertVtxoAssetProjection :exec
INSERT INTO asset_projection (asset_id, txid, vout, amount)
VALUES ($1, $2, $3, $4)
`

type InsertVtxoAssetProjectionParams struct {
	AssetID string
	Txid    string
	Vout    int32
	Amount  string
}

func (q *Queries) InsertVtxoAssetProjection(ctx context.Context, arg InsertVtxoAssetProjectionParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxoAssetProjection,
		arg.AssetID,
		arg.Txid,
		arg.Vout,
		arg.Amount,
	)
	return err
}

const insertVtxoCommitmentTxid = `-- name: InsertVtxoCommitmentTxid :exec
INSERT INTO vtxo_commitment_txid (vtxo_txid, vtxo_vout, commitment_txid)
VALUES ($1, $2, $3)
`

type InsertVtxoCommitmentTxidParams struct {
	VtxoTxid       string
	VtxoVout       int32
	CommitmentTxid string
}

func (q *Queries) InsertVtxoCommitmentTxid(ctx context.Context, arg InsertVtxoCommitmentTxidParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxoCommitmentTxid, arg.VtxoTxid, arg.VtxoVout, arg.CommitmentTxid)
	return err
}

const isMarkerSwept = `-- name: IsMarkerSwept :one
SELECT EXISTS(SELECT 1 FROM swept_marker WHERE marker_id = $1) AS is_swept
`

func (q *Queries) IsMarkerSwept(ctx context.Context, markerID string) (bool, error) {
	row := q.db.QueryRowContext(ctx, isMarkerSwept, markerID)
	var is_swept bool
	err := row.Scan(&is_swept)
	return is_swept, err
}

const selectActiveScriptConvictions = `-- name: SelectActiveScriptConvictions :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE script = $1 
AND pardoned = false 
AND (expires_at IS NULL OR expires_at > $2)
ORDER BY created_at ASC
`

type SelectActiveScriptConvictionsParams struct {
	Script    sql.NullString
	ExpiresAt sql.NullInt64
}

func (q *Queries) SelectActiveScriptConvictions(ctx context.Context, arg SelectActiveScriptConvictionsParams) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectActiveScriptConvictions, arg.Script, arg.ExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllRoundIds = `-- name: SelectAllRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectAllRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectAllRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw
`

type SelectAllVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]SelectAllVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllVtxosRow
	for rows.Next() {
		var i SelectAllVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAssetExists = `-- name: SelectAssetExists :one
SELECT 1 FROM asset WHERE id = $1 LIMIT 1
`

func (q *Queries) SelectAssetExists(ctx context.Context, id string) (int32, error) {
	row := q.db.QueryRowContext(ctx, selectAssetExists, id)
	var column_1 int32
	err := row.Scan(&column_1)
	return column_1, err
}

const selectAssetSupply = `-- name: SelectAssetSupply :one
SELECT (COALESCE(SUM(ap.amount), 0))::TEXT AS supply
FROM asset_projection ap
INNER JOIN vtxo v ON v.txid = ap.txid AND v.vout = ap.vout
WHERE ap.asset_id = $1 AND v.spent = false
`

func (q *Queries) SelectAssetSupply(ctx context.Context, assetID string) (string, error) {
	row := q.db.QueryRowContext(ctx, selectAssetSupply, assetID)
	var supply string
	err := row.Scan(&supply)
	return supply, err
}

const selectAssetsByIds = `-- name: SelectAssetsByIds :many
SELECT id, is_immutable, metadata_hash, metadata, control_asset_id FROM asset WHERE asset.id = ANY($1::varchar[])
`

func (q *Queries) SelectAssetsByIds(ctx context.Context, dollar_1 []string) ([]Asset, error) {
	rows, err := q.db.QueryContext(ctx, selectAssetsByIds, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.IsImmutable,
			&i.MetadataHash,
			&i.Metadata,
			&i.ControlAssetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectControlAssetByID = `-- name: SelectControlAssetByID :one
SELECT control_asset_id FROM asset WHERE id = $1
`

func (q *Queries) SelectControlAssetByID(ctx context.Context, id string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, selectControlAssetByID, id)
	var control_asset_id sql.NullString
	err := row.Scan(&control_asset_id)
	return control_asset_id, err
}

const selectConviction = `-- name: SelectConviction :one
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction WHERE id = $1
`

func (q *Queries) SelectConviction(ctx context.Context, id string) (Conviction, error) {
	row := q.db.QueryRowContext(ctx, selectConviction, id)
	var i Conviction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.CrimeType,
		&i.CrimeRoundID,
		&i.CrimeReason,
		&i.Pardoned,
		&i.Script,
	)
	return i, err
}

const selectConvictionsByRoundID = `-- name: SelectConvictionsByRoundID :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE crime_round_id = $1
ORDER BY created_at ASC
`

func (q *Queries) SelectConvictionsByRoundID(ctx context.Context, roundID string) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectConvictionsByRoundID, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectConvictionsInTimeRange = `-- name: SelectConvictionsInTimeRange :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE created_at >= $1 AND created_at <= $2
ORDER BY created_at ASC
`

type SelectConvictionsInTimeRangeParams struct {
	FromTime int64
	ToTime   int64
}

func (q *Queries) SelectConvictionsInTimeRange(ctx context.Context, arg SelectConvictionsInTimeRangeParams) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectConvictionsInTimeRange, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectExpiringLiquidityAmount = `-- name: SelectExpiringLiquidityAmount :one
SELECT COALESCE(SUM(v.amount), 0)::bigint AS amount
FROM vtxo v
WHERE NOT EXISTS (
        SELECT 1 FROM swept_marker sm
        WHERE v.markers @> jsonb_build_array(sm.marker_id)
    )
  AND v.spent = false
  AND v.unrolled = false
  AND v.expires_at > $1
  AND ($2 <= 0 OR v.expires_at < $2)
`

type SelectExpiringLiquidityAmountParams struct {
	After  int64
	Before interface{}
}

func (q *Queries) SelectExpiringLiquidityAmount(ctx context.Context, arg SelectExpiringLiquidityAmountParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, selectExpiringLiquidityAmount, arg.After, arg.Before)
	var amount int64
	err := row.Scan(&amount)
	return amount, err
}

const selectIntentByTxid = `-- name: SelectIntentByTxid :one
SELECT id, txid, proof, message FROM intent
WHERE txid = $1
`

type SelectIntentByTxidRow struct {
	ID      sql.NullString
	Txid    sql.NullString
	Proof   sql.NullString
	Message sql.NullString
}

func (q *Queries) SelectIntentByTxid(ctx context.Context, txid sql.NullString) (SelectIntentByTxidRow, error) {
	row := q.db.QueryRowContext(ctx, selectIntentByTxid, txid)
	var i SelectIntentByTxidRow
	err := row.Scan(
		&i.ID,
		&i.Txid,
		&i.Proof,
		&i.Message,
	)
	return i, err
}

const selectLatestIntentFees = `-- name: SelectLatestIntentFees :one
SELECT id, created_at, offchain_input_fee_program, onchain_input_fee_program, offchain_output_fee_program, onchain_output_fee_program FROM intent_fees ORDER BY id DESC LIMIT 1
`

func (q *Queries) SelectLatestIntentFees(ctx context.Context) (IntentFee, error) {
	row := q.db.QueryRowContext(ctx, selectLatestIntentFees)
	var i IntentFee
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.OffchainInputFeeProgram,
		&i.OnchainInputFeeProgram,
		&i.OffchainOutputFeeProgram,
		&i.OnchainOutputFeeProgram,
	)
	return i, err
}

const selectLatestScheduledSession = `-- name: SelectLatestScheduledSession :one
SELECT id, start_time, end_time, period, duration, round_min_participants, round_max_participants, updated_at FROM scheduled_session ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) SelectLatestScheduledSession(ctx context.Context) (ScheduledSession, error) {
	row := q.db.QueryRowContext(ctx, selectLatestScheduledSession)
	var i ScheduledSession
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.Duration,
		&i.RoundMinParticipants,
		&i.RoundMaxParticipants,
		&i.UpdatedAt,
	)
	return i, err
}

const selectMarker = `-- name: SelectMarker :one
SELECT id, depth, parent_markers FROM marker WHERE id = $1
`

func (q *Queries) SelectMarker(ctx context.Context, id string) (Marker, error) {
	row := q.db.QueryRowContext(ctx, selectMarker, id)
	var i Marker
	err := row.Scan(&i.ID, &i.Depth, &i.ParentMarkers)
	return i, err
}

const selectMarkersByDepth = `-- name: SelectMarkersByDepth :many
SELECT id, depth, parent_markers FROM marker WHERE depth = $1
`

func (q *Queries) SelectMarkersByDepth(ctx context.Context, depth int32) ([]Marker, error) {
	rows, err := q.db.QueryContext(ctx, selectMarkersByDepth, depth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Marker
	for rows.Next() {
		var i Marker
		if err := rows.Scan(&i.ID, &i.Depth, &i.ParentMarkers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMarkersByDepthRange = `-- name: SelectMarkersByDepthRange :many
SELECT id, depth, parent_markers FROM marker WHERE depth >= $1 AND depth <= $2 ORDER BY depth
`

type SelectMarkersByDepthRangeParams struct {
	MinDepth int32
	MaxDepth int32
}

func (q *Queries) SelectMarkersByDepthRange(ctx context.Context, arg SelectMarkersByDepthRangeParams) ([]Marker, error) {
	rows, err := q.db.QueryContext(ctx, selectMarkersByDepthRange, arg.MinDepth, arg.MaxDepth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Marker
	for rows.Next() {
		var i Marker
		if err := rows.Scan(&i.ID, &i.Depth, &i.ParentMarkers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMarkersByIds = `-- name: SelectMarkersByIds :many
SELECT id, depth, parent_markers FROM marker WHERE id = ANY($1::text[])
`

func (q *Queries) SelectMarkersByIds(ctx context.Context, ids []string) ([]Marker, error) {
	rows, err := q.db.QueryContext(ctx, selectMarkersByIds, pq.Array(ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Marker
	for rows.Next() {
		var i Marker
		if err := rows.Scan(&i.ID, &i.Depth, &i.ParentMarkers); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotUnrolledVtxos = `-- name: SelectNotUnrolledVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE unrolled = false
`

type SelectNotUnrolledVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectNotUnrolledVtxos(ctx context.Context) ([]SelectNotUnrolledVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotUnrolledVtxosWithPubkey = `-- name: SelectNotUnrolledVtxosWithPubkey :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE unrolled = false AND pubkey = $1
`

type SelectNotUnrolledVtxosWithPubkeyRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectNotUnrolledVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotUnrolledVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOffchainTx = `-- name: SelectOffchainTx :many
SELECT offchain_tx_vw.txid, offchain_tx_vw.tx, offchain_tx_vw.starting_timestamp, offchain_tx_vw.ending_timestamp, offchain_tx_vw.expiry_timestamp, offchain_tx_vw.fail_reason, offchain_tx_vw.stage_code, offchain_tx_vw.checkpoint_txid, offchain_tx_vw.checkpoint_tx, offchain_tx_vw.commitment_txid, offchain_tx_vw.is_root_commitment_txid, offchain_tx_vw.offchain_txid FROM offchain_tx_vw WHERE txid = $1 AND COALESCE(fail_reason, '') = ''
`

type SelectOffchainTxRow struct {
	OffchainTxVw OffchainTxVw
}

func (q *Queries) SelectOffchainTx(ctx context.Context, txid string) ([]SelectOffchainTxRow, error) {
	rows, err := q.db.QueryContext(ctx, selectOffchainTx, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectOffchainTxRow
	for rows.Next() {
		var i SelectOffchainTxRow
		if err := rows.Scan(
			&i.OffchainTxVw.Txid,
			&i.OffchainTxVw.Tx,
			&i.OffchainTxVw.StartingTimestamp,
			&i.OffchainTxVw.EndingTimestamp,
			&i.OffchainTxVw.ExpiryTimestamp,
			&i.OffchainTxVw.FailReason,
			&i.OffchainTxVw.StageCode,
			&i.OffchainTxVw.CheckpointTxid,
			&i.OffchainTxVw.CheckpointTx,
			&i.OffchainTxVw.CommitmentTxid,
			&i.OffchainTxVw.IsRootCommitmentTxid,
			&i.OffchainTxVw.OffchainTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPendingSpentVtxo = `-- name: SelectPendingSpentVtxo :many
SELECT v.txid, v.vout, v.pubkey, v.amount, v.expires_at, v.created_at, v.commitment_txid, v.spent_by, v.spent, v.unrolled, v.preconfirmed, v.settled_by, v.ark_txid, v.intent_id, v.updated_at, v.depth, v.markers, v.commitments, v.swept, v.asset_id, v.asset_amount
FROM vtxo_vw v
WHERE v.txid = $1 AND v.vout = $2
    AND v.spent = TRUE AND v.unrolled = FALSE and COALESCE(v.settled_by, '') = ''
    AND v.ark_txid IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM vtxo AS o WHERE o.txid = v.ark_txid
    )
`

type SelectPendingSpentVtxoParams struct {
	Txid string
	Vout int32
}

func (q *Queries) SelectPendingSpentVtxo(ctx context.Context, arg SelectPendingSpentVtxoParams) ([]VtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectPendingSpentVtxo, arg.Txid, arg.Vout)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoVw
	for rows.Next() {
		var i VtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CommitmentTxid,
			&i.SpentBy,
			&i.Spent,
			&i.Unrolled,
			&i.Preconfirmed,
			&i.SettledBy,
			&i.ArkTxid,
			&i.IntentID,
			&i.UpdatedAt,
			&i.Depth,
			&i.Markers,
			&i.Commitments,
			&i.Swept,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPendingSpentVtxosWithPubkeys = `-- name: SelectPendingSpentVtxosWithPubkeys :many
SELECT v.txid, v.vout, v.pubkey, v.amount, v.expires_at, v.created_at, v.commitment_txid, v.spent_by, v.spent, v.unrolled, v.preconfirmed, v.settled_by, v.ark_txid, v.intent_id, v.updated_at, v.depth, v.markers, v.commitments, v.swept, v.asset_id, v.asset_amount
FROM vtxo_vw v
WHERE v.spent = TRUE AND v.unrolled = FALSE and COALESCE(v.settled_by, '') = ''
    AND v.pubkey = ANY($1::varchar[])
    AND v.ark_txid IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM vtxo AS o WHERE o.txid = v.ark_txid
    )
    AND v.updated_at >= $2::bigint
    AND ($3::bigint = 0 OR v.updated_at <= $3::bigint)
`

type SelectPendingSpentVtxosWithPubkeysParams struct {
	Column1 []string
	After   int64
	Before  int64
}

func (q *Queries) SelectPendingSpentVtxosWithPubkeys(ctx context.Context, arg SelectPendingSpentVtxosWithPubkeysParams) ([]VtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectPendingSpentVtxosWithPubkeys, pq.Array(arg.Column1), arg.After, arg.Before)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoVw
	for rows.Next() {
		var i VtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CommitmentTxid,
			&i.SpentBy,
			&i.Spent,
			&i.Unrolled,
			&i.Preconfirmed,
			&i.SettledBy,
			&i.ArkTxid,
			&i.IntentID,
			&i.UpdatedAt,
			&i.Depth,
			&i.Markers,
			&i.Commitments,
			&i.Swept,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRecoverableLiquidityAmount = `-- name: SelectRecoverableLiquidityAmount :one
SELECT COALESCE(SUM(v.amount), 0)::bigint AS amount
FROM vtxo v
WHERE EXISTS (
        SELECT 1 FROM swept_marker sm
        WHERE v.markers @> jsonb_build_array(sm.marker_id)
    )
  AND v.spent = false
`

func (q *Queries) SelectRecoverableLiquidityAmount(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, selectRecoverableLiquidityAmount)
	var amount int64
	err := row.Scan(&amount)
	return amount, err
}

const selectRoundConnectors = `-- name: SelectRoundConnectors :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
) AND t.type = 'connector'
`

func (q *Queries) SelectRoundConnectors(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundConnectors, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundForfeitTxs = `-- name: SelectRoundForfeitTxs :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id IN (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
) AND t.type = 'forfeit'
`

func (q *Queries) SelectRoundForfeitTxs(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundForfeitTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInTimeRange = `-- name: SelectRoundIdsInTimeRange :many
SELECT id FROM round WHERE starting_timestamp > $1 AND starting_timestamp < $2
`

type SelectRoundIdsInTimeRangeParams struct {
	StartTs int64
	EndTs   int64
}

func (q *Queries) SelectRoundIdsInTimeRange(ctx context.Context, arg SelectRoundIdsInTimeRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInTimeRange, arg.StartTs, arg.EndTs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInTimeRangeWithFilters = `-- name: SelectRoundIdsInTimeRangeWithFilters :many
SELECT id FROM round 
WHERE starting_timestamp > $1 
  AND starting_timestamp < $2
  AND ($3::boolean = true OR failed = false)
  AND ($4::boolean = true OR ended = false)
`

type SelectRoundIdsInTimeRangeWithFiltersParams struct {
	StartTs       int64
	EndTs         int64
	WithFailed    bool
	WithCompleted bool
}

func (q *Queries) SelectRoundIdsInTimeRangeWithFilters(ctx context.Context, arg SelectRoundIdsInTimeRangeWithFiltersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInTimeRangeWithFilters,
		arg.StartTs,
		arg.EndTs,
		arg.WithFailed,
		arg.WithCompleted,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsWithFilters = `-- name: SelectRoundIdsWithFilters :many
SELECT id FROM round 
WHERE ($1::boolean = true OR failed = false)
  AND ($2::boolean = true OR ended = false)
`

type SelectRoundIdsWithFiltersParams struct {
	WithFailed    bool
	WithCompleted bool
}

func (q *Queries) SelectRoundIdsWithFilters(ctx context.Context, arg SelectRoundIdsWithFiltersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsWithFilters, arg.WithFailed, arg.WithCompleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundStats = `-- name: SelectRoundStats :one
SELECT
    r.swept,
    r.starting_timestamp,
    r.ending_timestamp,
    (
        SELECT COALESCE(SUM(ii.amount), 0)::bigint FROM intent_with_inputs_vw ii WHERE ii.round_id = r.id
    ) AS total_forfeit_amount,
    (
        SELECT COALESCE(COUNT(ii.txid), 0)::bigint FROM intent_with_inputs_vw ii WHERE ii.round_id = r.id
    ) AS total_input_vtxos,
    (
        SELECT COALESCE(SUM(ir.amount), 0)::bigint FROM intent_with_receivers_vw ir
        WHERE ir.round_id = r.id AND COALESCE(ir.onchain_address, '') = ''
    ) AS total_batch_amount,
    (
        SELECT COUNT(*) FROM intent_with_receivers_vw ir WHERE ir.round_id = r.id AND COALESCE(ir.onchain_address, '') = ''
    ) AS total_output_vtxos,
    (
        SELECT MAX(v.expires_at) FROM vtxo_vw v WHERE v.commitment_txid = r.txid
    ) AS expires_at
FROM round_with_commitment_tx_vw r
WHERE r.txid = $1
`

type SelectRoundStatsRow struct {
	Swept              bool
	StartingTimestamp  int64
	EndingTimestamp    int64
	TotalForfeitAmount int64
	TotalInputVtxos    int64
	TotalBatchAmount   int64
	TotalOutputVtxos   int64
	ExpiresAt          interface{}
}

func (q *Queries) SelectRoundStats(ctx context.Context, txid string) (SelectRoundStatsRow, error) {
	row := q.db.QueryRowContext(ctx, selectRoundStats, txid)
	var i SelectRoundStatsRow
	err := row.Scan(
		&i.Swept,
		&i.StartingTimestamp,
		&i.EndingTimestamp,
		&i.TotalForfeitAmount,
		&i.TotalInputVtxos,
		&i.TotalBatchAmount,
		&i.TotalOutputVtxos,
		&i.ExpiresAt,
	)
	return i, err
}

const selectRoundVtxoTree = `-- name: SelectRoundVtxoTree :many
SELECT txid, tx, round_id, type, position, children FROM tx WHERE round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
) AND type = 'tree'
`

func (q *Queries) SelectRoundVtxoTree(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTree, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundVtxoTreeLeaves = `-- name: SelectRoundVtxoTreeLeaves :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE commitment_txid = $1 AND preconfirmed = false
`

type SelectRoundVtxoTreeLeavesRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectRoundVtxoTreeLeaves(ctx context.Context, commitmentTxid string) ([]SelectRoundVtxoTreeLeavesRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTreeLeaves, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundVtxoTreeLeavesRow
	for rows.Next() {
		var i SelectRoundVtxoTreeLeavesRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithId = `-- name: SelectRoundWithId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message, round_intents_vw.txid,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children,
    intent_with_receivers_vw.intent_id, intent_with_receivers_vw.pubkey, intent_with_receivers_vw.onchain_address, intent_with_receivers_vw.amount, intent_with_receivers_vw.id, intent_with_receivers_vw.round_id, intent_with_receivers_vw.proof, intent_with_receivers_vw.message, intent_with_receivers_vw.txid,
    intent_with_inputs_vw.txid, intent_with_inputs_vw.vout, intent_with_inputs_vw.pubkey, intent_with_inputs_vw.amount, intent_with_inputs_vw.expires_at, intent_with_inputs_vw.created_at, intent_with_inputs_vw.commitment_txid, intent_with_inputs_vw.spent_by, intent_with_inputs_vw.spent, intent_with_inputs_vw.unrolled, intent_with_inputs_vw.preconfirmed, intent_with_inputs_vw.settled_by, intent_with_inputs_vw.ark_txid, intent_with_inputs_vw.intent_id, intent_with_inputs_vw.updated_at, intent_with_inputs_vw.depth, intent_with_inputs_vw.markers, intent_with_inputs_vw.commitments, intent_with_inputs_vw.swept, intent_with_inputs_vw.asset_id, intent_with_inputs_vw.asset_amount, intent_with_inputs_vw.id, intent_with_inputs_vw.round_id, intent_with_inputs_vw.proof, intent_with_inputs_vw.message, intent_with_inputs_vw.intent_txid
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
LEFT OUTER JOIN intent_with_receivers_vw ON round_intents_vw.id=intent_with_receivers_vw.intent_id
LEFT OUTER JOIN intent_with_inputs_vw ON round_intents_vw.id=intent_with_inputs_vw.intent_id
WHERE round.id = $1
`

type SelectRoundWithIdRow struct {
	Round                 Round
	RoundIntentsVw        RoundIntentsVw
	RoundTxsVw            RoundTxsVw
	IntentWithReceiversVw IntentWithReceiversVw
	IntentWithInputsVw    IntentWithInputsVw
}

func (q *Queries) SelectRoundWithId(ctx context.Context, id string) ([]SelectRoundWithIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithIdRow
	for rows.Next() {
		var i SelectRoundWithIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundIntentsVw.Txid,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
			&i.IntentWithReceiversVw.IntentID,
			&i.IntentWithReceiversVw.Pubkey,
			&i.IntentWithReceiversVw.OnchainAddress,
			&i.IntentWithReceiversVw.Amount,
			&i.IntentWithReceiversVw.ID,
			&i.IntentWithReceiversVw.RoundID,
			&i.IntentWithReceiversVw.Proof,
			&i.IntentWithReceiversVw.Message,
			&i.IntentWithReceiversVw.Txid,
			&i.IntentWithInputsVw.Txid,
			&i.IntentWithInputsVw.Vout,
			&i.IntentWithInputsVw.Pubkey,
			&i.IntentWithInputsVw.Amount,
			&i.IntentWithInputsVw.ExpiresAt,
			&i.IntentWithInputsVw.CreatedAt,
			&i.IntentWithInputsVw.CommitmentTxid,
			&i.IntentWithInputsVw.SpentBy,
			&i.IntentWithInputsVw.Spent,
			&i.IntentWithInputsVw.Unrolled,
			&i.IntentWithInputsVw.Preconfirmed,
			&i.IntentWithInputsVw.SettledBy,
			&i.IntentWithInputsVw.ArkTxid,
			&i.IntentWithInputsVw.IntentID,
			&i.IntentWithInputsVw.UpdatedAt,
			&i.IntentWithInputsVw.Depth,
			&i.IntentWithInputsVw.Markers,
			&i.IntentWithInputsVw.Commitments,
			&i.IntentWithInputsVw.Swept,
			&i.IntentWithInputsVw.AssetID,
			&i.IntentWithInputsVw.AssetAmount,
			&i.IntentWithInputsVw.ID,
			&i.IntentWithInputsVw.RoundID,
			&i.IntentWithInputsVw.Proof,
			&i.IntentWithInputsVw.Message,
			&i.IntentWithInputsVw.IntentTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithTxid = `-- name: SelectRoundWithTxid :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message, round_intents_vw.txid,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children,
    intent_with_receivers_vw.intent_id, intent_with_receivers_vw.pubkey, intent_with_receivers_vw.onchain_address, intent_with_receivers_vw.amount, intent_with_receivers_vw.id, intent_with_receivers_vw.round_id, intent_with_receivers_vw.proof, intent_with_receivers_vw.message, intent_with_receivers_vw.txid,
    intent_with_inputs_vw.txid, intent_with_inputs_vw.vout, intent_with_inputs_vw.pubkey, intent_with_inputs_vw.amount, intent_with_inputs_vw.expires_at, intent_with_inputs_vw.created_at, intent_with_inputs_vw.commitment_txid, intent_with_inputs_vw.spent_by, intent_with_inputs_vw.spent, intent_with_inputs_vw.unrolled, intent_with_inputs_vw.preconfirmed, intent_with_inputs_vw.settled_by, intent_with_inputs_vw.ark_txid, intent_with_inputs_vw.intent_id, intent_with_inputs_vw.updated_at, intent_with_inputs_vw.depth, intent_with_inputs_vw.markers, intent_with_inputs_vw.commitments, intent_with_inputs_vw.swept, intent_with_inputs_vw.asset_id, intent_with_inputs_vw.asset_amount, intent_with_inputs_vw.id, intent_with_inputs_vw.round_id, intent_with_inputs_vw.proof, intent_with_inputs_vw.message, intent_with_inputs_vw.intent_txid
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
LEFT OUTER JOIN intent_with_receivers_vw ON round_intents_vw.id=intent_with_receivers_vw.intent_id
LEFT OUTER JOIN intent_with_inputs_vw ON round_intents_vw.id=intent_with_inputs_vw.intent_id
WHERE round.id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = $1 AND type = 'commitment'
)
`

type SelectRoundWithTxidRow struct {
	Round                 Round
	RoundIntentsVw        RoundIntentsVw
	RoundTxsVw            RoundTxsVw
	IntentWithReceiversVw IntentWithReceiversVw
	IntentWithInputsVw    IntentWithInputsVw
}

func (q *Queries) SelectRoundWithTxid(ctx context.Context, txid string) ([]SelectRoundWithTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithTxidRow
	for rows.Next() {
		var i SelectRoundWithTxidRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundIntentsVw.Txid,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
			&i.IntentWithReceiversVw.IntentID,
			&i.IntentWithReceiversVw.Pubkey,
			&i.IntentWithReceiversVw.OnchainAddress,
			&i.IntentWithReceiversVw.Amount,
			&i.IntentWithReceiversVw.ID,
			&i.IntentWithReceiversVw.RoundID,
			&i.IntentWithReceiversVw.Proof,
			&i.IntentWithReceiversVw.Message,
			&i.IntentWithReceiversVw.Txid,
			&i.IntentWithInputsVw.Txid,
			&i.IntentWithInputsVw.Vout,
			&i.IntentWithInputsVw.Pubkey,
			&i.IntentWithInputsVw.Amount,
			&i.IntentWithInputsVw.ExpiresAt,
			&i.IntentWithInputsVw.CreatedAt,
			&i.IntentWithInputsVw.CommitmentTxid,
			&i.IntentWithInputsVw.SpentBy,
			&i.IntentWithInputsVw.Spent,
			&i.IntentWithInputsVw.Unrolled,
			&i.IntentWithInputsVw.Preconfirmed,
			&i.IntentWithInputsVw.SettledBy,
			&i.IntentWithInputsVw.ArkTxid,
			&i.IntentWithInputsVw.IntentID,
			&i.IntentWithInputsVw.UpdatedAt,
			&i.IntentWithInputsVw.Depth,
			&i.IntentWithInputsVw.Markers,
			&i.IntentWithInputsVw.Commitments,
			&i.IntentWithInputsVw.Swept,
			&i.IntentWithInputsVw.AssetID,
			&i.IntentWithInputsVw.AssetAmount,
			&i.IntentWithInputsVw.ID,
			&i.IntentWithInputsVw.RoundID,
			&i.IntentWithInputsVw.Proof,
			&i.IntentWithInputsVw.Message,
			&i.IntentWithInputsVw.IntentTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundsWithTxids = `-- name: SelectRoundsWithTxids :many
SELECT txid FROM tx WHERE type = 'commitment' AND tx.txid = ANY($1::varchar[])
`

func (q *Queries) SelectRoundsWithTxids(ctx context.Context, dollar_1 []string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundsWithTxids, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableRounds = `-- name: SelectSweepableRounds :many
SELECT txid FROM round_with_commitment_tx_vw r 
WHERE r.swept = false AND r.ended = true AND r.failed = false
AND EXISTS (
    SELECT 1 FROM tx tree_tx 
    WHERE tree_tx.round_id = r.id AND tree_tx.type = 'tree'
)
`

func (q *Queries) SelectSweepableRounds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableRounds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableUnrolledVtxos = `-- name: SelectSweepableUnrolledVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE spent = true AND unrolled = true AND swept = false AND COALESCE(settled_by, '') = ''
`

type SelectSweepableUnrolledVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectSweepableUnrolledVtxos(ctx context.Context) ([]SelectSweepableUnrolledVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableUnrolledVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableUnrolledVtxosRow
	for rows.Next() {
		var i SelectSweepableUnrolledVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxoOutpointsByCommitmentTxid = `-- name: SelectSweepableVtxoOutpointsByCommitmentTxid :many
SELECT DISTINCT v.txid AS vtxo_txid, v.vout AS vtxo_vout
FROM vtxo_vw v
WHERE v.swept = false
  AND (v.commitment_txid = $1
    OR (',' || COALESCE(v.commitments::text, '') || ',') LIKE '%,' || $1 || ',%')
`

type SelectSweepableVtxoOutpointsByCommitmentTxidRow struct {
	VtxoTxid string
	VtxoVout int32
}

func (q *Queries) SelectSweepableVtxoOutpointsByCommitmentTxid(ctx context.Context, commitmentTxid string) ([]SelectSweepableVtxoOutpointsByCommitmentTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxoOutpointsByCommitmentTxid, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableVtxoOutpointsByCommitmentTxidRow
	for rows.Next() {
		var i SelectSweepableVtxoOutpointsByCommitmentTxidRow
		if err := rows.Scan(&i.VtxoTxid, &i.VtxoVout); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptMarker = `-- name: SelectSweptMarker :one
SELECT marker_id, swept_at FROM swept_marker WHERE marker_id = $1
`

func (q *Queries) SelectSweptMarker(ctx context.Context, markerID string) (SweptMarker, error) {
	row := q.db.QueryRowContext(ctx, selectSweptMarker, markerID)
	var i SweptMarker
	err := row.Scan(&i.MarkerID, &i.SweptAt)
	return i, err
}

const selectSweptMarkersByIds = `-- name: SelectSweptMarkersByIds :many
SELECT marker_id, swept_at FROM swept_marker WHERE marker_id = ANY($1::text[])
`

func (q *Queries) SelectSweptMarkersByIds(ctx context.Context, markerIds []string) ([]SweptMarker, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptMarkersByIds, pq.Array(markerIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SweptMarker
	for rows.Next() {
		var i SweptMarker
		if err := rows.Scan(&i.MarkerID, &i.SweptAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTxs = `-- name: SelectTxs :many
SELECT tx.txid, tx.tx AS data FROM tx WHERE tx.txid = ANY($1::varchar[])
UNION
SELECT offchain_tx.txid, offchain_tx.tx AS data FROM offchain_tx WHERE offchain_tx.txid = ANY($1::varchar[])
UNION
SELECT checkpoint_tx.txid, checkpoint_tx.tx AS data FROM checkpoint_tx WHERE checkpoint_tx.txid = ANY($1::varchar[])
`

type SelectTxsRow struct {
	Txid string
	Data string
}

func (q *Queries) SelectTxs(ctx context.Context, dollar_1 []string) ([]SelectTxsRow, error) {
	rows, err := q.db.QueryContext(ctx, selectTxs, pq.Array(dollar_1))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTxsRow
	for rows.Next() {
		var i SelectTxsRow
		if err := rows.Scan(&i.Txid, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxo = `-- name: SelectVtxo :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE txid = $1 AND vout = $2
`

type SelectVtxoParams struct {
	Txid string
	Vout int32
}

type SelectVtxoRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectVtxo(ctx context.Context, arg SelectVtxoParams) ([]SelectVtxoRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxo, arg.Txid, arg.Vout)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxoRow
	for rows.Next() {
		var i SelectVtxoRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoChainByMarker = `-- name: SelectVtxoChainByMarker :many
SELECT txid, vout, pubkey, amount, expires_at, created_at, commitment_txid, spent_by, spent, unrolled, preconfirmed, settled_by, ark_txid, intent_id, updated_at, depth, markers, commitments, swept, asset_id, asset_amount FROM vtxo_vw
WHERE markers ?| $1::TEXT[]
ORDER BY depth DESC
`

// Get VTXOs whose markers JSONB array contains any of the given marker IDs
func (q *Queries) SelectVtxoChainByMarker(ctx context.Context, markerIds []string) ([]VtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxoChainByMarker, pq.Array(markerIds))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoVw
	for rows.Next() {
		var i VtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CommitmentTxid,
			&i.SpentBy,
			&i.Spent,
			&i.Unrolled,
			&i.Preconfirmed,
			&i.SettledBy,
			&i.ArkTxid,
			&i.IntentID,
			&i.UpdatedAt,
			&i.Depth,
			&i.Markers,
			&i.Commitments,
			&i.Swept,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoPubKeysByCommitmentTxid = `-- name: SelectVtxoPubKeysByCommitmentTxid :many
SELECT DISTINCT v.pubkey 
FROM vtxo_vw v
WHERE v.amount >= $1
  AND (v.commitment_txid = $2
    OR (',' || COALESCE(v.commitments::text, '') || ',') LIKE '%,' || $2 || ',%')
`

type SelectVtxoPubKeysByCommitmentTxidParams struct {
	MinAmount      int64
	CommitmentTxid string
}

func (q *Queries) SelectVtxoPubKeysByCommitmentTxid(ctx context.Context, arg SelectVtxoPubKeysByCommitmentTxidParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxoPubKeysByCommitmentTxid, arg.MinAmount, arg.CommitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var pubkey string
		if err := rows.Scan(&pubkey); err != nil {
			return nil, err
		}
		items = append(items, pubkey)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosByArkTxid = `-- name: SelectVtxosByArkTxid :many
SELECT txid, vout, pubkey, amount, expires_at, created_at, commitment_txid, spent_by, spent, unrolled, preconfirmed, settled_by, ark_txid, intent_id, updated_at, depth, markers, commitments, swept, asset_id, asset_amount FROM vtxo_vw WHERE ark_txid = $1
`

// Get all VTXOs created by a specific ark tx (offchain tx)
func (q *Queries) SelectVtxosByArkTxid(ctx context.Context, arkTxid string) ([]VtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosByArkTxid, arkTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoVw
	for rows.Next() {
		var i VtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CommitmentTxid,
			&i.SpentBy,
			&i.Spent,
			&i.Unrolled,
			&i.Preconfirmed,
			&i.SettledBy,
			&i.ArkTxid,
			&i.IntentID,
			&i.UpdatedAt,
			&i.Depth,
			&i.Markers,
			&i.Commitments,
			&i.Swept,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosByDepthRange = `-- name: SelectVtxosByDepthRange :many

SELECT txid, vout, pubkey, amount, expires_at, created_at, commitment_txid, spent_by, spent, unrolled, preconfirmed, settled_by, ark_txid, intent_id, updated_at, depth, markers, commitments, swept, asset_id, asset_amount FROM vtxo_vw
WHERE depth >= $1 AND depth <= $2
ORDER BY depth DESC
`

type SelectVtxosByDepthRangeParams struct {
	MinDepth int32
	MaxDepth int32
}

// Chain traversal queries for GetVtxoChain optimization
// Get all VTXOs within a depth range, useful for filling gaps between markers
func (q *Queries) SelectVtxosByDepthRange(ctx context.Context, arg SelectVtxosByDepthRangeParams) ([]VtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosByDepthRange, arg.MinDepth, arg.MaxDepth)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoVw
	for rows.Next() {
		var i VtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CommitmentTxid,
			&i.SpentBy,
			&i.Spent,
			&i.Unrolled,
			&i.Preconfirmed,
			&i.SettledBy,
			&i.ArkTxid,
			&i.IntentID,
			&i.UpdatedAt,
			&i.Depth,
			&i.Markers,
			&i.Commitments,
			&i.Swept,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosByMarkerId = `-- name: SelectVtxosByMarkerId :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE markers @> jsonb_build_array($1::TEXT)
`

type SelectVtxosByMarkerIdRow struct {
	VtxoVw VtxoVw
}

// Find VTXOs whose markers JSONB array contains the given marker_id
func (q *Queries) SelectVtxosByMarkerId(ctx context.Context, markerID string) ([]SelectVtxosByMarkerIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosByMarkerId, markerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosByMarkerIdRow
	for rows.Next() {
		var i SelectVtxosByMarkerIdRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosOutpointsByArkTxidRecursive = `-- name: SelectVtxosOutpointsByArkTxidRecursive :many
WITH RECURSIVE descendants_chain AS (
    -- seed
    SELECT v.txid, v.vout, v.preconfirmed, v.ark_txid, v.spent_by,
           0 AS depth,
           ARRAY[(v.txid||':'||v.vout)]::text[] AS visited
    FROM vtxo v
    WHERE v.txid = $1

    UNION ALL

    -- children: next vtxo(s) are those whose txid == current.ark_txid
    SELECT c.txid, c.vout, c.preconfirmed, c.ark_txid, c.spent_by,
           w.depth + 1,
           w.visited || (c.txid||':'||c.vout)
    FROM descendants_chain w
             JOIN vtxo c
                  ON c.txid = w.ark_txid
    WHERE w.ark_txid IS NOT NULL
      AND (c.txid||':'||c.vout) <> ALL (w.visited)   -- cycle/visited guard
),
nodes AS (
   SELECT DISTINCT ON (txid, vout)
       txid, vout, preconfirmed, depth
   FROM descendants_chain
   ORDER BY txid, vout, depth
)
SELECT txid, vout
FROM nodes
ORDER BY depth, txid, vout
`

type SelectVtxosOutpointsByArkTxidRecursiveRow struct {
	Txid string
	Vout int32
}

// keep one row per node at its MIN depth (layers)
func (q *Queries) SelectVtxosOutpointsByArkTxidRecursive(ctx context.Context, txid string) ([]SelectVtxosOutpointsByArkTxidRecursiveRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosOutpointsByArkTxidRecursive, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosOutpointsByArkTxidRecursiveRow
	for rows.Next() {
		var i SelectVtxosOutpointsByArkTxidRecursiveRow
		if err := rows.Scan(&i.Txid, &i.Vout); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosWithPubkeys = `-- name: SelectVtxosWithPubkeys :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.depth, vtxo_vw.markers, vtxo_vw.commitments, vtxo_vw.swept, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw
WHERE vtxo_vw.pubkey = ANY($1::varchar[])
    AND vtxo_vw.updated_at >= $2::bigint
    AND ($3::bigint = 0 OR vtxo_vw.updated_at <= $3::bigint)
`

type SelectVtxosWithPubkeysParams struct {
	Column1 []string
	After   int64
	Before  int64
}

type SelectVtxosWithPubkeysRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectVtxosWithPubkeys(ctx context.Context, arg SelectVtxosWithPubkeysParams) ([]SelectVtxosWithPubkeysRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosWithPubkeys, pq.Array(arg.Column1), arg.After, arg.Before)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithPubkeysRow
	for rows.Next() {
		var i SelectVtxosWithPubkeysRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Depth,
			&i.VtxoVw.Markers,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.Swept,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConvictionPardoned = `-- name: UpdateConvictionPardoned :exec
UPDATE conviction SET pardoned = true WHERE id = $1
`

func (q *Queries) UpdateConvictionPardoned(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateConvictionPardoned, id)
	return err
}

const updateVtxoExpiration = `-- name: UpdateVtxoExpiration :exec
UPDATE vtxo SET expires_at = $1 WHERE txid = $2 AND vout = $3
`

type UpdateVtxoExpirationParams struct {
	ExpiresAt int64
	Txid      string
	Vout      int32
}

func (q *Queries) UpdateVtxoExpiration(ctx context.Context, arg UpdateVtxoExpirationParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpiration, arg.ExpiresAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoIntentId = `-- name: UpdateVtxoIntentId :exec
UPDATE vtxo SET intent_id = $1 WHERE txid = $2 AND vout = $3
`

type UpdateVtxoIntentIdParams struct {
	IntentID sql.NullString
	Txid     string
	Vout     int32
}

func (q *Queries) UpdateVtxoIntentId(ctx context.Context, arg UpdateVtxoIntentIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoIntentId, arg.IntentID, arg.Txid, arg.Vout)
	return err
}

const updateVtxoMarkers = `-- name: UpdateVtxoMarkers :exec
UPDATE vtxo SET markers = $1::jsonb WHERE txid = $2 AND vout = $3
`

type UpdateVtxoMarkersParams struct {
	Markers json.RawMessage
	Txid    string
	Vout    int32
}

func (q *Queries) UpdateVtxoMarkers(ctx context.Context, arg UpdateVtxoMarkersParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoMarkers, arg.Markers, arg.Txid, arg.Vout)
	return err
}

const updateVtxoSettled = `-- name: UpdateVtxoSettled :exec
UPDATE vtxo SET spent = true, spent_by = $1, settled_by = $2, updated_at = (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT
WHERE txid = $3 AND vout = $4
`

type UpdateVtxoSettledParams struct {
	SpentBy   sql.NullString
	SettledBy sql.NullString
	Txid      string
	Vout      int32
}

func (q *Queries) UpdateVtxoSettled(ctx context.Context, arg UpdateVtxoSettledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSettled,
		arg.SpentBy,
		arg.SettledBy,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoSpent = `-- name: UpdateVtxoSpent :exec
UPDATE vtxo SET spent = true, spent_by = $1, ark_txid = $2, updated_at = (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT
WHERE txid = $3 AND vout = $4
`

type UpdateVtxoSpentParams struct {
	SpentBy sql.NullString
	ArkTxid sql.NullString
	Txid    string
	Vout    int32
}

func (q *Queries) UpdateVtxoSpent(ctx context.Context, arg UpdateVtxoSpentParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSpent,
		arg.SpentBy,
		arg.ArkTxid,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoUnrolled = `-- name: UpdateVtxoUnrolled :exec
UPDATE vtxo SET unrolled = true, updated_at = (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT WHERE txid = $1 AND vout = $2
`

type UpdateVtxoUnrolledParams struct {
	Txid string
	Vout int32
}

func (q *Queries) UpdateVtxoUnrolled(ctx context.Context, arg UpdateVtxoUnrolledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoUnrolled, arg.Txid, arg.Vout)
	return err
}

const upsertCheckpointTx = `-- name: UpsertCheckpointTx :exec
INSERT INTO checkpoint_tx (txid, tx, commitment_txid, is_root_commitment_txid, offchain_txid)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    commitment_txid = EXCLUDED.commitment_txid,
    is_root_commitment_txid = EXCLUDED.is_root_commitment_txid,
    offchain_txid = EXCLUDED.offchain_txid
`

type UpsertCheckpointTxParams struct {
	Txid                 string
	Tx                   string
	CommitmentTxid       string
	IsRootCommitmentTxid bool
	OffchainTxid         string
}

func (q *Queries) UpsertCheckpointTx(ctx context.Context, arg UpsertCheckpointTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertCheckpointTx,
		arg.Txid,
		arg.Tx,
		arg.CommitmentTxid,
		arg.IsRootCommitmentTxid,
		arg.OffchainTxid,
	)
	return err
}

const upsertConviction = `-- name: UpsertConviction :exec
INSERT INTO conviction (
    id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
ON CONFLICT(id) DO UPDATE SET
    pardoned = EXCLUDED.pardoned
`

type UpsertConvictionParams struct {
	ID           string
	Type         int32
	CreatedAt    int64
	ExpiresAt    sql.NullInt64
	CrimeType    int32
	CrimeRoundID string
	CrimeReason  string
	Pardoned     bool
	Script       sql.NullString
}

func (q *Queries) UpsertConviction(ctx context.Context, arg UpsertConvictionParams) error {
	_, err := q.db.ExecContext(ctx, upsertConviction,
		arg.ID,
		arg.Type,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.CrimeType,
		arg.CrimeRoundID,
		arg.CrimeReason,
		arg.Pardoned,
		arg.Script,
	)
	return err
}

const upsertIntent = `-- name: UpsertIntent :exec
INSERT INTO intent (id, round_id, proof, message, txid) VALUES ($1, $2, $3, $4, $5)
ON CONFLICT(id) DO UPDATE SET
    round_id = EXCLUDED.round_id,
    proof = EXCLUDED.proof,
    message = EXCLUDED.message,
    txid = EXCLUDED.txid
`

type UpsertIntentParams struct {
	ID      sql.NullString
	RoundID sql.NullString
	Proof   sql.NullString
	Message sql.NullString
	Txid    sql.NullString
}

func (q *Queries) UpsertIntent(ctx context.Context, arg UpsertIntentParams) error {
	_, err := q.db.ExecContext(ctx, upsertIntent,
		arg.ID,
		arg.RoundID,
		arg.Proof,
		arg.Message,
		arg.Txid,
	)
	return err
}

const upsertMarker = `-- name: UpsertMarker :exec

INSERT INTO marker (id, depth, parent_markers)
VALUES ($1, $2, $3)
ON CONFLICT(id) DO UPDATE SET
    depth = EXCLUDED.depth,
    parent_markers = EXCLUDED.parent_markers
`

type UpsertMarkerParams struct {
	ID            string
	Depth         int32
	ParentMarkers pqtype.NullRawMessage
}

// Marker queries
func (q *Queries) UpsertMarker(ctx context.Context, arg UpsertMarkerParams) error {
	_, err := q.db.ExecContext(ctx, upsertMarker, arg.ID, arg.Depth, arg.ParentMarkers)
	return err
}

const upsertOffchainTx = `-- name: UpsertOffchainTx :exec
INSERT INTO offchain_tx (txid, tx, starting_timestamp, ending_timestamp, expiry_timestamp, fail_reason, stage_code)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    expiry_timestamp = EXCLUDED.expiry_timestamp,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code
`

type UpsertOffchainTxParams struct {
	Txid              string
	Tx                string
	StartingTimestamp int64
	EndingTimestamp   int64
	ExpiryTimestamp   int64
	FailReason        sql.NullString
	StageCode         int32
}

func (q *Queries) UpsertOffchainTx(ctx context.Context, arg UpsertOffchainTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertOffchainTx,
		arg.Txid,
		arg.Tx,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.ExpiryTimestamp,
		arg.FailReason,
		arg.StageCode,
	)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (intent_id, pubkey, onchain_address, amount)
VALUES ($1, $2, $3, $4)
ON CONFLICT(intent_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	IntentID       string
	Pubkey         string
	OnchainAddress string
	Amount         int64
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.IntentID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id, starting_timestamp, ending_timestamp, ended, failed, fail_reason,
    stage_code, connector_address, version, swept, vtxo_tree_expiration
) VALUES (
    $1, $2, $3, $4, $5, $6,
    $7, $8, $9, $10, $11
)
ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code,
    connector_address = EXCLUDED.connector_address,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept,
    vtxo_tree_expiration = EXCLUDED.vtxo_tree_expiration
`

type UpsertRoundParams struct {
	ID                 string
	StartingTimestamp  int64
	EndingTimestamp    int64
	Ended              bool
	Failed             bool
	FailReason         sql.NullString
	StageCode          int32
	ConnectorAddress   string
	Version            int32
	Swept              bool
	VtxoTreeExpiration int64
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.FailReason,
		arg.StageCode,
		arg.ConnectorAddress,
		arg.Version,
		arg.Swept,
		arg.VtxoTreeExpiration,
	)
	return err
}

const upsertScheduledSession = `-- name: UpsertScheduledSession :exec
INSERT INTO scheduled_session (id, start_time, end_time, period, duration, round_min_participants, round_max_participants, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (id) DO UPDATE SET
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    period = EXCLUDED.period,
    duration = EXCLUDED.duration,
    round_min_participants = EXCLUDED.round_min_participants,
    round_max_participants = EXCLUDED.round_max_participants,
    updated_at = EXCLUDED.updated_at
`

type UpsertScheduledSessionParams struct {
	ID                   int32
	StartTime            int64
	EndTime              int64
	Period               int64
	Duration             int64
	RoundMinParticipants int64
	RoundMaxParticipants int64
	UpdatedAt            int64
}

func (q *Queries) UpsertScheduledSession(ctx context.Context, arg UpsertScheduledSessionParams) error {
	_, err := q.db.ExecContext(ctx, upsertScheduledSession,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.Duration,
		arg.RoundMinParticipants,
		arg.RoundMaxParticipants,
		arg.UpdatedAt,
	)
	return err
}

const upsertTx = `-- name: UpsertTx :exec
INSERT INTO tx (tx, round_id, type, position, txid, children)
VALUES ($1, $2, $3, $4, $5, $6)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    children = EXCLUDED.children
`

type UpsertTxParams struct {
	Tx       string
	RoundID  string
	Type     string
	Position int32
	Txid     string
	Children pqtype.NullRawMessage
}

func (q *Queries) UpsertTx(ctx context.Context, arg UpsertTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertTx,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.Children,
	)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (
    txid, vout, pubkey, amount, commitment_txid, settled_by, ark_txid,
    spent_by, spent, unrolled, preconfirmed, expires_at, created_at, updated_at, depth, markers
)
VALUES (
    $1, $2, $3, $4, $5, $6, $7,
    $8, $9, $10, $11, $12, $13, (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT, $14, $15
) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    commitment_txid = EXCLUDED.commitment_txid,
    settled_by = EXCLUDED.settled_by,
    ark_txid = EXCLUDED.ark_txid,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    unrolled = EXCLUDED.unrolled,
    preconfirmed = EXCLUDED.preconfirmed,
    expires_at = EXCLUDED.expires_at,
    created_at = EXCLUDED.created_at,
    updated_at = (EXTRACT(EPOCH FROM NOW()) * 1000)::BIGINT,
    depth = EXCLUDED.depth,
    markers = EXCLUDED.markers
`

type UpsertVtxoParams struct {
	Txid           string
	Vout           int32
	Pubkey         string
	Amount         int64
	CommitmentTxid string
	SettledBy      sql.NullString
	ArkTxid        sql.NullString
	SpentBy        sql.NullString
	Spent          bool
	Unrolled       bool
	Preconfirmed   bool
	ExpiresAt      int64
	CreatedAt      int64
	Depth          int32
	Markers        json.RawMessage
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.CommitmentTxid,
		arg.SettledBy,
		arg.ArkTxid,
		arg.SpentBy,
		arg.Spent,
		arg.Unrolled,
		arg.Preconfirmed,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.Depth,
		arg.Markers,
	)
	return err
}
