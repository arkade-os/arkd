// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const addIntentFees = `-- name: AddIntentFees :exec
INSERT INTO intent_fees (
  offchain_input_fee_program,
  onchain_input_fee_program,
  offchain_output_fee_program,
  onchain_output_fee_program
)
SELECT
    -- if all fee programs are empty, set them all to empty, else use provided, but if provided is empty fetch and use latest for that fee program.
    -- if no rows exist in intent_fees, and a specific fee program is passed in as empty, default to empty string. 
  CASE
    WHEN (?1 = '' AND ?2 = '' AND ?3 = '' AND ?4 = '') THEN ''
    WHEN ?1 != '' THEN ?1
    ELSE COALESCE((SELECT offchain_input_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END,
  CASE
    WHEN (?1 = '' AND ?2 = '' AND ?3 = '' AND ?4 = '') THEN ''
    WHEN ?2 != '' THEN ?2
    ELSE COALESCE((SELECT onchain_input_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END,
  CASE
    WHEN (?1 = '' AND ?2 = '' AND ?3 = '' AND ?4 = '') THEN ''
    WHEN ?3 != '' THEN ?3
    ELSE COALESCE((SELECT offchain_output_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END,
  CASE
    WHEN (?1 = '' AND ?2 = '' AND ?3 = '' AND ?4 = '') THEN ''
    WHEN ?4 != '' THEN ?4
    ELSE COALESCE((SELECT onchain_output_fee_program FROM intent_fees ORDER BY created_at DESC LIMIT 1), '')
  END
`

type AddIntentFeesParams struct {
	OffchainInputFeeProgram  interface{}
	OnchainInputFeeProgram   interface{}
	OffchainOutputFeeProgram interface{}
	OnchainOutputFeeProgram  interface{}
}

func (q *Queries) AddIntentFees(ctx context.Context, arg AddIntentFeesParams) error {
	_, err := q.db.ExecContext(ctx, addIntentFees,
		arg.OffchainInputFeeProgram,
		arg.OnchainInputFeeProgram,
		arg.OffchainOutputFeeProgram,
		arg.OnchainOutputFeeProgram,
	)
	return err
}

const clearIntentFees = `-- name: ClearIntentFees :exec
INSERT INTO intent_fees (
  offchain_input_fee_program,
  onchain_input_fee_program,
  offchain_output_fee_program,
  onchain_output_fee_program
)
VALUES ('', '', '', '')
`

func (q *Queries) ClearIntentFees(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearIntentFees)
	return err
}

const clearScheduledSession = `-- name: ClearScheduledSession :exec
DELETE FROM scheduled_session
`

func (q *Queries) ClearScheduledSession(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearScheduledSession)
	return err
}

const clearSettings = `-- name: ClearSettings :exec
DELETE FROM settings
`

func (q *Queries) ClearSettings(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearSettings)
	return err
}

const insertAsset = `-- name: InsertAsset :exec
INSERT INTO asset (id, is_immutable, metadata_hash, metadata, control_asset_id)
VALUES (?1, ?2, ?3, ?4, ?5)
`

type InsertAssetParams struct {
	ID             string
	IsImmutable    bool
	MetadataHash   sql.NullString
	Metadata       sql.NullString
	ControlAssetID sql.NullString
}

func (q *Queries) InsertAsset(ctx context.Context, arg InsertAssetParams) error {
	_, err := q.db.ExecContext(ctx, insertAsset,
		arg.ID,
		arg.IsImmutable,
		arg.MetadataHash,
		arg.Metadata,
		arg.ControlAssetID,
	)
	return err
}

const insertVtxoAssetProjection = `-- name: InsertVtxoAssetProjection :exec
INSERT INTO asset_projection (asset_id, txid, vout, amount)
VALUES (?1, ?2, ?3, ?4)
`

type InsertVtxoAssetProjectionParams struct {
	AssetID string
	Txid    string
	Vout    int64
	Amount  string
}

func (q *Queries) InsertVtxoAssetProjection(ctx context.Context, arg InsertVtxoAssetProjectionParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxoAssetProjection,
		arg.AssetID,
		arg.Txid,
		arg.Vout,
		arg.Amount,
	)
	return err
}

const insertVtxoCommitmentTxid = `-- name: InsertVtxoCommitmentTxid :exec
INSERT INTO vtxo_commitment_txid (vtxo_txid, vtxo_vout, commitment_txid)
VALUES (?1, ?2, ?3)
`

type InsertVtxoCommitmentTxidParams struct {
	VtxoTxid       string
	VtxoVout       int64
	CommitmentTxid string
}

func (q *Queries) InsertVtxoCommitmentTxid(ctx context.Context, arg InsertVtxoCommitmentTxidParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxoCommitmentTxid, arg.VtxoTxid, arg.VtxoVout, arg.CommitmentTxid)
	return err
}

const selectActiveScriptConvictions = `-- name: SelectActiveScriptConvictions :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE script = ?1 
AND pardoned = false 
AND (expires_at IS NULL OR expires_at > ?2)
ORDER BY created_at ASC
`

type SelectActiveScriptConvictionsParams struct {
	Script    sql.NullString
	ExpiresAt sql.NullInt64
}

func (q *Queries) SelectActiveScriptConvictions(ctx context.Context, arg SelectActiveScriptConvictionsParams) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectActiveScriptConvictions, arg.Script, arg.ExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllRoundIds = `-- name: SelectAllRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectAllRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectAllRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.commitments, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw
`

type SelectAllVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]SelectAllVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllVtxosRow
	for rows.Next() {
		var i SelectAllVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAssetAmounts = `-- name: SelectAssetAmounts :many
SELECT v.asset_amount FROM vtxo_vw v
WHERE v.asset_id = ? AND v.spent = false AND v.asset_amount > 0
`

func (q *Queries) SelectAssetAmounts(ctx context.Context, assetID string) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectAssetAmounts, assetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var asset_amount string
		if err := rows.Scan(&asset_amount); err != nil {
			return nil, err
		}
		items = append(items, asset_amount)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAssetExists = `-- name: SelectAssetExists :one
SELECT 1 FROM asset WHERE id = ? LIMIT 1
`

func (q *Queries) SelectAssetExists(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, selectAssetExists, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const selectAssetsByIds = `-- name: SelectAssetsByIds :many
SELECT id, is_immutable, metadata_hash, metadata, control_asset_id FROM asset WHERE asset.id IN (/*SLICE:ids*/?)
`

func (q *Queries) SelectAssetsByIds(ctx context.Context, ids []string) ([]Asset, error) {
	query := selectAssetsByIds
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Asset
	for rows.Next() {
		var i Asset
		if err := rows.Scan(
			&i.ID,
			&i.IsImmutable,
			&i.MetadataHash,
			&i.Metadata,
			&i.ControlAssetID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectControlAssetByID = `-- name: SelectControlAssetByID :one
SELECT control_asset_id FROM asset WHERE id = ?
`

func (q *Queries) SelectControlAssetByID(ctx context.Context, id string) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, selectControlAssetByID, id)
	var control_asset_id sql.NullString
	err := row.Scan(&control_asset_id)
	return control_asset_id, err
}

const selectConviction = `-- name: SelectConviction :one
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction WHERE id = ?1
`

func (q *Queries) SelectConviction(ctx context.Context, id string) (Conviction, error) {
	row := q.db.QueryRowContext(ctx, selectConviction, id)
	var i Conviction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.CrimeType,
		&i.CrimeRoundID,
		&i.CrimeReason,
		&i.Pardoned,
		&i.Script,
	)
	return i, err
}

const selectConvictionsByRoundID = `-- name: SelectConvictionsByRoundID :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE crime_round_id = ?1
ORDER BY created_at ASC
`

func (q *Queries) SelectConvictionsByRoundID(ctx context.Context, roundID string) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectConvictionsByRoundID, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectConvictionsInTimeRange = `-- name: SelectConvictionsInTimeRange :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE created_at >= ?1 AND created_at <= ?2
ORDER BY created_at ASC
`

type SelectConvictionsInTimeRangeParams struct {
	FromTime int64
	ToTime   int64
}

func (q *Queries) SelectConvictionsInTimeRange(ctx context.Context, arg SelectConvictionsInTimeRangeParams) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectConvictionsInTimeRange, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectExpiringLiquidityAmount = `-- name: SelectExpiringLiquidityAmount :one
SELECT COALESCE(SUM(amount), 0) AS amount
FROM vtxo
WHERE swept = false
  AND spent = false
  AND unrolled = false
  AND expires_at > ?1
  AND (?2 <= 0 OR expires_at < ?2)
`

type SelectExpiringLiquidityAmountParams struct {
	After  int64
	Before interface{}
}

func (q *Queries) SelectExpiringLiquidityAmount(ctx context.Context, arg SelectExpiringLiquidityAmountParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, selectExpiringLiquidityAmount, arg.After, arg.Before)
	var amount interface{}
	err := row.Scan(&amount)
	return amount, err
}

const selectIntentByTxid = `-- name: SelectIntentByTxid :one
SELECT id, txid, proof, message FROM intent
WHERE txid = ?1
`

type SelectIntentByTxidRow struct {
	ID      sql.NullString
	Txid    sql.NullString
	Proof   sql.NullString
	Message sql.NullString
}

func (q *Queries) SelectIntentByTxid(ctx context.Context, txid sql.NullString) (SelectIntentByTxidRow, error) {
	row := q.db.QueryRowContext(ctx, selectIntentByTxid, txid)
	var i SelectIntentByTxidRow
	err := row.Scan(
		&i.ID,
		&i.Txid,
		&i.Proof,
		&i.Message,
	)
	return i, err
}

const selectIntentReceiversByRoundId = `-- name: SelectIntentReceiversByRoundId :many
SELECT intent_with_receivers_vw.intent_id, intent_with_receivers_vw.pubkey, intent_with_receivers_vw.onchain_address, intent_with_receivers_vw.amount, intent_with_receivers_vw.id, intent_with_receivers_vw.round_id, intent_with_receivers_vw.proof, intent_with_receivers_vw.message, intent_with_receivers_vw.txid
FROM intent_with_receivers_vw
WHERE intent_with_receivers_vw.round_id = ?1
`

type SelectIntentReceiversByRoundIdRow struct {
	IntentWithReceiversVw IntentWithReceiversVw
}

func (q *Queries) SelectIntentReceiversByRoundId(ctx context.Context, roundID sql.NullString) ([]SelectIntentReceiversByRoundIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectIntentReceiversByRoundId, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectIntentReceiversByRoundIdRow
	for rows.Next() {
		var i SelectIntentReceiversByRoundIdRow
		if err := rows.Scan(
			&i.IntentWithReceiversVw.IntentID,
			&i.IntentWithReceiversVw.Pubkey,
			&i.IntentWithReceiversVw.OnchainAddress,
			&i.IntentWithReceiversVw.Amount,
			&i.IntentWithReceiversVw.ID,
			&i.IntentWithReceiversVw.RoundID,
			&i.IntentWithReceiversVw.Proof,
			&i.IntentWithReceiversVw.Message,
			&i.IntentWithReceiversVw.Txid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLatestIntentFees = `-- name: SelectLatestIntentFees :one
SELECT id, created_at, offchain_input_fee_program, onchain_input_fee_program, offchain_output_fee_program, onchain_output_fee_program FROM intent_fees ORDER BY id DESC LIMIT 1
`

func (q *Queries) SelectLatestIntentFees(ctx context.Context) (IntentFee, error) {
	row := q.db.QueryRowContext(ctx, selectLatestIntentFees)
	var i IntentFee
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.OffchainInputFeeProgram,
		&i.OnchainInputFeeProgram,
		&i.OffchainOutputFeeProgram,
		&i.OnchainOutputFeeProgram,
	)
	return i, err
}

const selectLatestScheduledSession = `-- name: SelectLatestScheduledSession :one
SELECT id, start_time, end_time, period, duration, round_min_participants, round_max_participants, updated_at FROM scheduled_session ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) SelectLatestScheduledSession(ctx context.Context) (ScheduledSession, error) {
	row := q.db.QueryRowContext(ctx, selectLatestScheduledSession)
	var i ScheduledSession
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.Duration,
		&i.RoundMinParticipants,
		&i.RoundMaxParticipants,
		&i.UpdatedAt,
	)
	return i, err
}

const selectLatestSettings = `-- name: SelectLatestSettings :one
SELECT id, ban_threshold, ban_duration, unilateral_exit_delay, public_unilateral_exit_delay, checkpoint_exit_delay, boarding_exit_delay, vtxo_tree_expiry, round_min_participants_count, round_max_participants_count, vtxo_min_amount, vtxo_max_amount, utxo_min_amount, utxo_max_amount, settlement_min_expiry_gap, vtxo_no_csv_validation_cutoff_date, max_tx_weight, updated_at FROM settings ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) SelectLatestSettings(ctx context.Context) (Setting, error) {
	row := q.db.QueryRowContext(ctx, selectLatestSettings)
	var i Setting
	err := row.Scan(
		&i.ID,
		&i.BanThreshold,
		&i.BanDuration,
		&i.UnilateralExitDelay,
		&i.PublicUnilateralExitDelay,
		&i.CheckpointExitDelay,
		&i.BoardingExitDelay,
		&i.VtxoTreeExpiry,
		&i.RoundMinParticipantsCount,
		&i.RoundMaxParticipantsCount,
		&i.VtxoMinAmount,
		&i.VtxoMaxAmount,
		&i.UtxoMinAmount,
		&i.UtxoMaxAmount,
		&i.SettlementMinExpiryGap,
		&i.VtxoNoCsvValidationCutoffDate,
		&i.MaxTxWeight,
		&i.UpdatedAt,
	)
	return i, err
}

const selectNotUnrolledVtxos = `-- name: SelectNotUnrolledVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.commitments, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE unrolled = false
`

type SelectNotUnrolledVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectNotUnrolledVtxos(ctx context.Context) ([]SelectNotUnrolledVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotUnrolledVtxosWithPubkey = `-- name: SelectNotUnrolledVtxosWithPubkey :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.commitments, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE unrolled = false AND pubkey = ?1
`

type SelectNotUnrolledVtxosWithPubkeyRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectNotUnrolledVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotUnrolledVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOffchainTx = `-- name: SelectOffchainTx :many
SELECT offchain_tx_vw.txid, offchain_tx_vw.tx, offchain_tx_vw.starting_timestamp, offchain_tx_vw.ending_timestamp, offchain_tx_vw.expiry_timestamp, offchain_tx_vw.fail_reason, offchain_tx_vw.stage_code, offchain_tx_vw.checkpoint_txid, offchain_tx_vw.checkpoint_tx, offchain_tx_vw.commitment_txid, offchain_tx_vw.is_root_commitment_txid, offchain_tx_vw.offchain_txid FROM offchain_tx_vw WHERE txid = ?1 AND COALESCE(fail_reason, '') = ''
`

type SelectOffchainTxRow struct {
	OffchainTxVw OffchainTxVw
}

func (q *Queries) SelectOffchainTx(ctx context.Context, txid string) ([]SelectOffchainTxRow, error) {
	rows, err := q.db.QueryContext(ctx, selectOffchainTx, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectOffchainTxRow
	for rows.Next() {
		var i SelectOffchainTxRow
		if err := rows.Scan(
			&i.OffchainTxVw.Txid,
			&i.OffchainTxVw.Tx,
			&i.OffchainTxVw.StartingTimestamp,
			&i.OffchainTxVw.EndingTimestamp,
			&i.OffchainTxVw.ExpiryTimestamp,
			&i.OffchainTxVw.FailReason,
			&i.OffchainTxVw.StageCode,
			&i.OffchainTxVw.CheckpointTxid,
			&i.OffchainTxVw.CheckpointTx,
			&i.OffchainTxVw.CommitmentTxid,
			&i.OffchainTxVw.IsRootCommitmentTxid,
			&i.OffchainTxVw.OffchainTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPendingSpentVtxo = `-- name: SelectPendingSpentVtxo :many
SELECT v.txid, v.vout, v.pubkey, v.amount, v.expires_at, v.created_at, v.commitment_txid, v.spent_by, v.spent, v.unrolled, v.swept, v.preconfirmed, v.settled_by, v.ark_txid, v.intent_id, v.updated_at, v.commitments, v.asset_id, v.asset_amount
FROM vtxo_vw v
WHERE v.txid = ?1 AND v.vout = ?2
    AND v.spent = TRUE AND v.unrolled = FALSE AND COALESCE(v.settled_by, '') = ''
    AND v.ark_txid IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM vtxo AS o WHERE o.txid = v.ark_txid
    )
`

type SelectPendingSpentVtxoParams struct {
	Txid string
	Vout int64
}

func (q *Queries) SelectPendingSpentVtxo(ctx context.Context, arg SelectPendingSpentVtxoParams) ([]VtxoVw, error) {
	rows, err := q.db.QueryContext(ctx, selectPendingSpentVtxo, arg.Txid, arg.Vout)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoVw
	for rows.Next() {
		var i VtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CommitmentTxid,
			&i.SpentBy,
			&i.Spent,
			&i.Unrolled,
			&i.Swept,
			&i.Preconfirmed,
			&i.SettledBy,
			&i.ArkTxid,
			&i.IntentID,
			&i.UpdatedAt,
			&i.Commitments,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectPendingSpentVtxosWithPubkeys = `-- name: SelectPendingSpentVtxosWithPubkeys :many
SELECT v.txid, v.vout, v.pubkey, v.amount, v.expires_at, v.created_at, v.commitment_txid, v.spent_by, v.spent, v.unrolled, v.swept, v.preconfirmed, v.settled_by, v.ark_txid, v.intent_id, v.updated_at, v.commitments, v.asset_id, v.asset_amount
FROM vtxo_vw v
WHERE v.spent = TRUE AND v.unrolled = FALSE AND COALESCE(v.settled_by, '') = ''
    AND v.pubkey IN (/*SLICE:pubkeys*/?)
    AND v.ark_txid IS NOT NULL AND NOT EXISTS (
        SELECT 1 FROM vtxo AS o WHERE o.txid = v.ark_txid
    )
    AND v.updated_at >= ?2
    AND (CAST(?3 AS INTEGER) = 0 OR v.updated_at <= CAST(?3 AS INTEGER))
`

type SelectPendingSpentVtxosWithPubkeysParams struct {
	Pubkeys []string
	After   sql.NullInt64
	Before  int64
}

func (q *Queries) SelectPendingSpentVtxosWithPubkeys(ctx context.Context, arg SelectPendingSpentVtxosWithPubkeysParams) ([]VtxoVw, error) {
	query := selectPendingSpentVtxosWithPubkeys
	var queryParams []interface{}
	if len(arg.Pubkeys) > 0 {
		for _, v := range arg.Pubkeys {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:pubkeys*/?", strings.Repeat(",?", len(arg.Pubkeys))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:pubkeys*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.After)
	queryParams = append(queryParams, arg.Before)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []VtxoVw
	for rows.Next() {
		var i VtxoVw
		if err := rows.Scan(
			&i.Txid,
			&i.Vout,
			&i.Pubkey,
			&i.Amount,
			&i.ExpiresAt,
			&i.CreatedAt,
			&i.CommitmentTxid,
			&i.SpentBy,
			&i.Spent,
			&i.Unrolled,
			&i.Swept,
			&i.Preconfirmed,
			&i.SettledBy,
			&i.ArkTxid,
			&i.IntentID,
			&i.UpdatedAt,
			&i.Commitments,
			&i.AssetID,
			&i.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRecoverableLiquidityAmount = `-- name: SelectRecoverableLiquidityAmount :one
SELECT COALESCE(SUM(amount), 0) AS amount
FROM vtxo
WHERE swept = true
  AND spent = false
`

func (q *Queries) SelectRecoverableLiquidityAmount(ctx context.Context) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, selectRecoverableLiquidityAmount)
	var amount interface{}
	err := row.Scan(&amount)
	return amount, err
}

const selectRoundConnectors = `-- name: SelectRoundConnectors :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
) AND t.type = 'connector'
`

func (q *Queries) SelectRoundConnectors(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundConnectors, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundForfeitTxs = `-- name: SelectRoundForfeitTxs :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id IN (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
) AND t.type = 'forfeit'
`

func (q *Queries) SelectRoundForfeitTxs(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundForfeitTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInTimeRange = `-- name: SelectRoundIdsInTimeRange :many
SELECT id FROM round WHERE starting_timestamp > ?1 AND starting_timestamp < ?2
`

type SelectRoundIdsInTimeRangeParams struct {
	StartTs int64
	EndTs   int64
}

func (q *Queries) SelectRoundIdsInTimeRange(ctx context.Context, arg SelectRoundIdsInTimeRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInTimeRange, arg.StartTs, arg.EndTs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInTimeRangeWithFilters = `-- name: SelectRoundIdsInTimeRangeWithFilters :many
SELECT id FROM round 
WHERE starting_timestamp > ?1 
  AND starting_timestamp < ?2
  AND (?3 = 1 OR failed = 0)
  AND (?4 = 1 OR ended = 0)
`

type SelectRoundIdsInTimeRangeWithFiltersParams struct {
	StartTs       int64
	EndTs         int64
	WithFailed    interface{}
	WithCompleted interface{}
}

func (q *Queries) SelectRoundIdsInTimeRangeWithFilters(ctx context.Context, arg SelectRoundIdsInTimeRangeWithFiltersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInTimeRangeWithFilters,
		arg.StartTs,
		arg.EndTs,
		arg.WithFailed,
		arg.WithCompleted,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsWithFilters = `-- name: SelectRoundIdsWithFilters :many
SELECT id FROM round 
WHERE (?1 = 1 OR failed = 0)
  AND (?2 = 1 OR ended = 0)
`

type SelectRoundIdsWithFiltersParams struct {
	WithFailed    interface{}
	WithCompleted interface{}
}

func (q *Queries) SelectRoundIdsWithFilters(ctx context.Context, arg SelectRoundIdsWithFiltersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsWithFilters, arg.WithFailed, arg.WithCompleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundStats = `-- name: SelectRoundStats :one
SELECT
    r.swept,
    r.starting_timestamp,
    r.ending_timestamp,
    (
        SELECT COALESCE(SUM(amount), 0) FROM (
            SELECT DISTINCT v2.txid, v2.vout, v2.pubkey, v2.amount, v2.expires_at, v2.created_at, v2.commitment_txid, v2.spent_by, v2.spent, v2.unrolled, v2.swept, v2.preconfirmed, v2.settled_by, v2.ark_txid, v2.intent_id, v2.updated_at FROM vtxo v2 JOIN intent i2 ON i2.id = v2.intent_id WHERE i2.round_id = r.id
        ) as intent_with_inputs_amount
    ) AS total_forfeit_amount,
    (
        SELECT COALESCE(COUNT(v3.txid), 0) FROM vtxo v3 JOIN intent i3 ON i3.id = v3.intent_id WHERE i3.round_id = r.id
    ) AS total_input_vtxos,
    (
        SELECT COALESCE(SUM(amount), 0) FROM (
            SELECT DISTINCT rr.intent_id, rr.pubkey, rr.onchain_address, rr.amount FROM receiver rr
            JOIN intent i4 ON i4.id = rr.intent_id
            WHERE i4.round_id = r.id AND COALESCE(rr.onchain_address, '') = ''
        ) AS intent_outputs_amount
    ) AS total_batch_amount,
    (
        SELECT COUNT(*) FROM tx t WHERE t.round_id = r.id AND t.type = 'tree' AND TRIM(COALESCE(t.children, '')) = ''
    ) AS total_output_vtxos,
    (
        SELECT MAX(v.expires_at) FROM vtxo_vw v WHERE v.commitment_txid = r.txid
    ) AS expires_at
FROM round_with_commitment_tx_vw r
WHERE r.txid = ?1
`

type SelectRoundStatsRow struct {
	Swept              bool
	StartingTimestamp  int64
	EndingTimestamp    int64
	TotalForfeitAmount interface{}
	TotalInputVtxos    interface{}
	TotalBatchAmount   interface{}
	TotalOutputVtxos   int64
	ExpiresAt          interface{}
}

func (q *Queries) SelectRoundStats(ctx context.Context, txid string) (SelectRoundStatsRow, error) {
	row := q.db.QueryRowContext(ctx, selectRoundStats, txid)
	var i SelectRoundStatsRow
	err := row.Scan(
		&i.Swept,
		&i.StartingTimestamp,
		&i.EndingTimestamp,
		&i.TotalForfeitAmount,
		&i.TotalInputVtxos,
		&i.TotalBatchAmount,
		&i.TotalOutputVtxos,
		&i.ExpiresAt,
	)
	return i, err
}

const selectRoundVtxoTree = `-- name: SelectRoundVtxoTree :many
SELECT txid, tx, round_id, type, position, children FROM tx WHERE round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
) AND type = 'tree'
`

func (q *Queries) SelectRoundVtxoTree(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTree, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundVtxoTreeLeaves = `-- name: SelectRoundVtxoTreeLeaves :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.commitments, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE commitment_txid = ?1 AND preconfirmed = false
`

type SelectRoundVtxoTreeLeavesRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectRoundVtxoTreeLeaves(ctx context.Context, commitmentTxid string) ([]SelectRoundVtxoTreeLeavesRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTreeLeaves, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundVtxoTreeLeavesRow
	for rows.Next() {
		var i SelectRoundVtxoTreeLeavesRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithId = `-- name: SelectRoundWithId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message, round_intents_vw.txid,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
WHERE round.id = ?1
`

type SelectRoundWithIdRow struct {
	Round          Round
	RoundIntentsVw RoundIntentsVw
	RoundTxsVw     RoundTxsVw
}

func (q *Queries) SelectRoundWithId(ctx context.Context, id string) ([]SelectRoundWithIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithIdRow
	for rows.Next() {
		var i SelectRoundWithIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundIntentsVw.Txid,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithTxid = `-- name: SelectRoundWithTxid :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message, round_intents_vw.txid,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
WHERE round.id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
)
`

type SelectRoundWithTxidRow struct {
	Round          Round
	RoundIntentsVw RoundIntentsVw
	RoundTxsVw     RoundTxsVw
}

func (q *Queries) SelectRoundWithTxid(ctx context.Context, txid string) ([]SelectRoundWithTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithTxidRow
	for rows.Next() {
		var i SelectRoundWithTxidRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundIntentsVw.Txid,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundsWithTxids = `-- name: SelectRoundsWithTxids :many
SELECT txid FROM tx WHERE type = 'commitment' AND tx.txid IN (/*SLICE:txids*/?)
`

func (q *Queries) SelectRoundsWithTxids(ctx context.Context, txids []string) ([]string, error) {
	query := selectRoundsWithTxids
	var queryParams []interface{}
	if len(txids) > 0 {
		for _, v := range txids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:txids*/?", strings.Repeat(",?", len(txids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:txids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableRounds = `-- name: SelectSweepableRounds :many
SELECT txid FROM round_with_commitment_tx_vw r 
WHERE r.swept = false AND r.ended = true AND r.failed = false
AND EXISTS (
    SELECT 1 FROM tx tree_tx 
    WHERE tree_tx.round_id = r.id AND tree_tx.type = 'tree'
)
`

func (q *Queries) SelectSweepableRounds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableRounds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableUnrolledVtxos = `-- name: SelectSweepableUnrolledVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.commitments, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE spent = true AND unrolled = true AND swept = false AND (COALESCE(settled_by, '') = '')
`

type SelectSweepableUnrolledVtxosRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectSweepableUnrolledVtxos(ctx context.Context) ([]SelectSweepableUnrolledVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableUnrolledVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableUnrolledVtxosRow
	for rows.Next() {
		var i SelectSweepableUnrolledVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxoOutpointsByCommitmentTxid = `-- name: SelectSweepableVtxoOutpointsByCommitmentTxid :many
SELECT DISTINCT v.txid AS vtxo_txid, v.vout AS vtxo_vout
FROM vtxo_vw v
WHERE v.swept = false
  AND (v.commitment_txid = ?1
    OR (',' || COALESCE(v.commitments, '') || ',') LIKE '%,' || ?1 || ',%')
`

type SelectSweepableVtxoOutpointsByCommitmentTxidRow struct {
	VtxoTxid string
	VtxoVout int64
}

func (q *Queries) SelectSweepableVtxoOutpointsByCommitmentTxid(ctx context.Context, commitmentTxid string) ([]SelectSweepableVtxoOutpointsByCommitmentTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxoOutpointsByCommitmentTxid, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableVtxoOutpointsByCommitmentTxidRow
	for rows.Next() {
		var i SelectSweepableVtxoOutpointsByCommitmentTxidRow
		if err := rows.Scan(&i.VtxoTxid, &i.VtxoVout); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTxs = `-- name: SelectTxs :many
SELECT tx.txid, tx.tx AS data FROM tx WHERE tx.txid IN (/*SLICE:ids1*/?)
UNION
SELECT offchain_tx.txid, offchain_tx.tx AS data FROM offchain_tx WHERE offchain_tx.txid IN (/*SLICE:ids2*/?)
UNION
SELECT checkpoint_tx.txid, checkpoint_tx.tx AS data FROM checkpoint_tx WHERE checkpoint_tx.txid IN (/*SLICE:ids3*/?)
`

type SelectTxsParams struct {
	Ids1 []string
	Ids2 []string
	Ids3 []string
}

type SelectTxsRow struct {
	Txid string
	Data string
}

func (q *Queries) SelectTxs(ctx context.Context, arg SelectTxsParams) ([]SelectTxsRow, error) {
	query := selectTxs
	var queryParams []interface{}
	if len(arg.Ids1) > 0 {
		for _, v := range arg.Ids1 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids1*/?", strings.Repeat(",?", len(arg.Ids1))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids1*/?", "NULL", 1)
	}
	if len(arg.Ids2) > 0 {
		for _, v := range arg.Ids2 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids2*/?", strings.Repeat(",?", len(arg.Ids2))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids2*/?", "NULL", 1)
	}
	if len(arg.Ids3) > 0 {
		for _, v := range arg.Ids3 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids3*/?", strings.Repeat(",?", len(arg.Ids3))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids3*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTxsRow
	for rows.Next() {
		var i SelectTxsRow
		if err := rows.Scan(&i.Txid, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxo = `-- name: SelectVtxo :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.commitments, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE txid = ?1 AND vout = ?2
`

type SelectVtxoParams struct {
	Txid string
	Vout int64
}

type SelectVtxoRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectVtxo(ctx context.Context, arg SelectVtxoParams) ([]SelectVtxoRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxo, arg.Txid, arg.Vout)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxoRow
	for rows.Next() {
		var i SelectVtxoRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoInputsByRoundId = `-- name: SelectVtxoInputsByRoundId :many
SELECT intent_with_inputs_vw.txid, intent_with_inputs_vw.vout, intent_with_inputs_vw.pubkey, intent_with_inputs_vw.amount, intent_with_inputs_vw.expires_at, intent_with_inputs_vw.created_at, intent_with_inputs_vw.commitment_txid, intent_with_inputs_vw.spent_by, intent_with_inputs_vw.spent, intent_with_inputs_vw.unrolled, intent_with_inputs_vw.swept, intent_with_inputs_vw.preconfirmed, intent_with_inputs_vw.settled_by, intent_with_inputs_vw.ark_txid, intent_with_inputs_vw.intent_id, intent_with_inputs_vw.updated_at, intent_with_inputs_vw.commitments, intent_with_inputs_vw.asset_id, intent_with_inputs_vw.asset_amount, intent_with_inputs_vw.id, intent_with_inputs_vw.round_id, intent_with_inputs_vw.proof, intent_with_inputs_vw.message, intent_with_inputs_vw.intent_txid
FROM intent_with_inputs_vw
WHERE intent_with_inputs_vw.round_id = ?1
`

type SelectVtxoInputsByRoundIdRow struct {
	IntentWithInputsVw IntentWithInputsVw
}

func (q *Queries) SelectVtxoInputsByRoundId(ctx context.Context, roundID sql.NullString) ([]SelectVtxoInputsByRoundIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxoInputsByRoundId, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxoInputsByRoundIdRow
	for rows.Next() {
		var i SelectVtxoInputsByRoundIdRow
		if err := rows.Scan(
			&i.IntentWithInputsVw.Txid,
			&i.IntentWithInputsVw.Vout,
			&i.IntentWithInputsVw.Pubkey,
			&i.IntentWithInputsVw.Amount,
			&i.IntentWithInputsVw.ExpiresAt,
			&i.IntentWithInputsVw.CreatedAt,
			&i.IntentWithInputsVw.CommitmentTxid,
			&i.IntentWithInputsVw.SpentBy,
			&i.IntentWithInputsVw.Spent,
			&i.IntentWithInputsVw.Unrolled,
			&i.IntentWithInputsVw.Swept,
			&i.IntentWithInputsVw.Preconfirmed,
			&i.IntentWithInputsVw.SettledBy,
			&i.IntentWithInputsVw.ArkTxid,
			&i.IntentWithInputsVw.IntentID,
			&i.IntentWithInputsVw.UpdatedAt,
			&i.IntentWithInputsVw.Commitments,
			&i.IntentWithInputsVw.AssetID,
			&i.IntentWithInputsVw.AssetAmount,
			&i.IntentWithInputsVw.ID,
			&i.IntentWithInputsVw.RoundID,
			&i.IntentWithInputsVw.Proof,
			&i.IntentWithInputsVw.Message,
			&i.IntentWithInputsVw.IntentTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxoPubKeysByCommitmentTxid = `-- name: SelectVtxoPubKeysByCommitmentTxid :many
SELECT DISTINCT v.pubkey
FROM vtxo_vw v
WHERE v.amount >= ?1
  AND (v.commitment_txid = ?2
    OR (',' || COALESCE(v.commitments, '') || ',') LIKE '%,' || ?2 || ',%')
`

type SelectVtxoPubKeysByCommitmentTxidParams struct {
	MinAmount      int64
	CommitmentTxid string
}

func (q *Queries) SelectVtxoPubKeysByCommitmentTxid(ctx context.Context, arg SelectVtxoPubKeysByCommitmentTxidParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxoPubKeysByCommitmentTxid, arg.MinAmount, arg.CommitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var pubkey string
		if err := rows.Scan(&pubkey); err != nil {
			return nil, err
		}
		items = append(items, pubkey)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosOutpointsByArkTxidRecursive = `-- name: SelectVtxosOutpointsByArkTxidRecursive :many
WITH RECURSIVE descendants_chain AS (
    -- seed
    SELECT v.txid, v.vout, v.preconfirmed, v.ark_txid, v.spent_by,
           0 AS depth,
           v.txid||':'||v.vout AS visited
    FROM vtxo v
    WHERE v.txid = ?1

    UNION ALL

    -- children: next vtxo(s) are those whose txid == current.ark_txid
    SELECT c.txid, c.vout, c.preconfirmed, c.ark_txid, c.spent_by,
           w.depth + 1,
           w.visited || ',' || (c.txid||':'||c.vout)
    FROM descendants_chain w
             JOIN vtxo c
                  ON c.txid = w.ark_txid
    WHERE w.ark_txid IS NOT NULL
      AND w.visited NOT LIKE '%' || (c.txid||':'||c.vout) || '%'   -- cycle/visited guard
),
nodes AS (
   SELECT txid, vout, preconfirmed, MIN(depth) as depth
   FROM descendants_chain
   GROUP BY txid, vout, preconfirmed
)
SELECT txid, vout
FROM nodes
ORDER BY depth, txid, vout
`

type SelectVtxosOutpointsByArkTxidRecursiveRow struct {
	Txid string
	Vout int64
}

// keep one row per node at its MIN depth (layers)
func (q *Queries) SelectVtxosOutpointsByArkTxidRecursive(ctx context.Context, txid string) ([]SelectVtxosOutpointsByArkTxidRecursiveRow, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxosOutpointsByArkTxidRecursive, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosOutpointsByArkTxidRecursiveRow
	for rows.Next() {
		var i SelectVtxosOutpointsByArkTxidRecursiveRow
		if err := rows.Scan(&i.Txid, &i.Vout); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosWithPubkeys = `-- name: SelectVtxosWithPubkeys :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.updated_at, vtxo_vw.commitments, vtxo_vw.asset_id, vtxo_vw.asset_amount FROM vtxo_vw WHERE pubkey IN (/*SLICE:pubkeys*/?)
    AND updated_at >= ?2
    AND (CAST(?3 AS INTEGER) = 0 OR updated_at <= CAST(?3 AS INTEGER))
`

type SelectVtxosWithPubkeysParams struct {
	Pubkeys []string
	After   sql.NullInt64
	Before  int64
}

type SelectVtxosWithPubkeysRow struct {
	VtxoVw VtxoVw
}

func (q *Queries) SelectVtxosWithPubkeys(ctx context.Context, arg SelectVtxosWithPubkeysParams) ([]SelectVtxosWithPubkeysRow, error) {
	query := selectVtxosWithPubkeys
	var queryParams []interface{}
	if len(arg.Pubkeys) > 0 {
		for _, v := range arg.Pubkeys {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:pubkeys*/?", strings.Repeat(",?", len(arg.Pubkeys))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:pubkeys*/?", "NULL", 1)
	}
	queryParams = append(queryParams, arg.After)
	queryParams = append(queryParams, arg.Before)
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithPubkeysRow
	for rows.Next() {
		var i SelectVtxosWithPubkeysRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.UpdatedAt,
			&i.VtxoVw.Commitments,
			&i.VtxoVw.AssetID,
			&i.VtxoVw.AssetAmount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConvictionPardoned = `-- name: UpdateConvictionPardoned :exec
UPDATE conviction SET pardoned = true WHERE id = ?1
`

func (q *Queries) UpdateConvictionPardoned(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateConvictionPardoned, id)
	return err
}

const updateVtxoExpiration = `-- name: UpdateVtxoExpiration :exec
UPDATE vtxo SET expires_at = ?1 WHERE txid = ?2 AND vout = ?3
`

type UpdateVtxoExpirationParams struct {
	ExpiresAt int64
	Txid      string
	Vout      int64
}

func (q *Queries) UpdateVtxoExpiration(ctx context.Context, arg UpdateVtxoExpirationParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpiration, arg.ExpiresAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoIntentId = `-- name: UpdateVtxoIntentId :exec
UPDATE vtxo SET intent_id = ?1 WHERE txid = ?2 AND vout = ?3
`

type UpdateVtxoIntentIdParams struct {
	IntentID sql.NullString
	Txid     string
	Vout     int64
}

func (q *Queries) UpdateVtxoIntentId(ctx context.Context, arg UpdateVtxoIntentIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoIntentId, arg.IntentID, arg.Txid, arg.Vout)
	return err
}

const updateVtxoSettled = `-- name: UpdateVtxoSettled :exec
UPDATE vtxo SET spent = true, spent_by = ?1, settled_by = ?2, updated_at = (CAST((strftime('%s','now') || substr(strftime('%f','now'),4,3)) AS INTEGER))
WHERE txid = ?3 AND vout = ?4
`

type UpdateVtxoSettledParams struct {
	SpentBy   sql.NullString
	SettledBy sql.NullString
	Txid      string
	Vout      int64
}

func (q *Queries) UpdateVtxoSettled(ctx context.Context, arg UpdateVtxoSettledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSettled,
		arg.SpentBy,
		arg.SettledBy,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoSpent = `-- name: UpdateVtxoSpent :exec
UPDATE vtxo SET spent = true, spent_by = ?1, ark_txid = ?2, updated_at = (CAST((strftime('%s','now') || substr(strftime('%f','now'),4,3)) AS INTEGER))
WHERE txid = ?3 AND vout = ?4
`

type UpdateVtxoSpentParams struct {
	SpentBy sql.NullString
	ArkTxid sql.NullString
	Txid    string
	Vout    int64
}

func (q *Queries) UpdateVtxoSpent(ctx context.Context, arg UpdateVtxoSpentParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSpent,
		arg.SpentBy,
		arg.ArkTxid,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoSweptIfNotSwept = `-- name: UpdateVtxoSweptIfNotSwept :execrows
UPDATE vtxo SET swept = true, updated_at = (CAST((strftime('%s','now') || substr(strftime('%f','now'),4,3)) AS INTEGER)) WHERE txid = ?1 AND vout = ?2 AND swept = false
`

type UpdateVtxoSweptIfNotSweptParams struct {
	Txid string
	Vout int64
}

func (q *Queries) UpdateVtxoSweptIfNotSwept(ctx context.Context, arg UpdateVtxoSweptIfNotSweptParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateVtxoSweptIfNotSwept, arg.Txid, arg.Vout)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateVtxoUnrolled = `-- name: UpdateVtxoUnrolled :exec
UPDATE vtxo SET unrolled = true, updated_at = (CAST((strftime('%s','now') || substr(strftime('%f','now'),4,3)) AS INTEGER)) WHERE txid = ?1 AND vout = ?2
`

type UpdateVtxoUnrolledParams struct {
	Txid string
	Vout int64
}

func (q *Queries) UpdateVtxoUnrolled(ctx context.Context, arg UpdateVtxoUnrolledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoUnrolled, arg.Txid, arg.Vout)
	return err
}

const upsertCheckpointTx = `-- name: UpsertCheckpointTx :exec
INSERT INTO checkpoint_tx (txid, tx, commitment_txid, is_root_commitment_txid, offchain_txid)
VALUES (?1, ?2, ?3, ?4, ?5)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    commitment_txid = EXCLUDED.commitment_txid,
    is_root_commitment_txid = EXCLUDED.is_root_commitment_txid,
    offchain_txid = EXCLUDED.offchain_txid
`

type UpsertCheckpointTxParams struct {
	Txid                 string
	Tx                   string
	CommitmentTxid       string
	IsRootCommitmentTxid bool
	OffchainTxid         string
}

func (q *Queries) UpsertCheckpointTx(ctx context.Context, arg UpsertCheckpointTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertCheckpointTx,
		arg.Txid,
		arg.Tx,
		arg.CommitmentTxid,
		arg.IsRootCommitmentTxid,
		arg.OffchainTxid,
	)
	return err
}

const upsertConviction = `-- name: UpsertConviction :exec
INSERT INTO conviction (
    id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script
) VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9
)
ON CONFLICT(id) DO UPDATE SET
    pardoned = EXCLUDED.pardoned
`

type UpsertConvictionParams struct {
	ID           string
	Type         int64
	CreatedAt    int64
	ExpiresAt    sql.NullInt64
	CrimeType    int64
	CrimeRoundID string
	CrimeReason  string
	Pardoned     bool
	Script       sql.NullString
}

func (q *Queries) UpsertConviction(ctx context.Context, arg UpsertConvictionParams) error {
	_, err := q.db.ExecContext(ctx, upsertConviction,
		arg.ID,
		arg.Type,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.CrimeType,
		arg.CrimeRoundID,
		arg.CrimeReason,
		arg.Pardoned,
		arg.Script,
	)
	return err
}

const upsertIntent = `-- name: UpsertIntent :exec
INSERT INTO intent (id, round_id, proof, message, txid) VALUES (?1, ?2, ?3, ?4, ?5)
ON CONFLICT(id) DO UPDATE SET
    round_id = EXCLUDED.round_id,
    proof = EXCLUDED.proof,
    message = EXCLUDED.message,
    txid = EXCLUDED.txid
`

type UpsertIntentParams struct {
	ID      sql.NullString
	RoundID sql.NullString
	Proof   sql.NullString
	Message sql.NullString
	Txid    sql.NullString
}

func (q *Queries) UpsertIntent(ctx context.Context, arg UpsertIntentParams) error {
	_, err := q.db.ExecContext(ctx, upsertIntent,
		arg.ID,
		arg.RoundID,
		arg.Proof,
		arg.Message,
		arg.Txid,
	)
	return err
}

const upsertOffchainTx = `-- name: UpsertOffchainTx :exec
INSERT INTO offchain_tx (txid, tx, starting_timestamp, ending_timestamp, expiry_timestamp, fail_reason, stage_code)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    expiry_timestamp = EXCLUDED.expiry_timestamp,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code
`

type UpsertOffchainTxParams struct {
	Txid              string
	Tx                string
	StartingTimestamp int64
	EndingTimestamp   int64
	ExpiryTimestamp   int64
	FailReason        sql.NullString
	StageCode         int64
}

func (q *Queries) UpsertOffchainTx(ctx context.Context, arg UpsertOffchainTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertOffchainTx,
		arg.Txid,
		arg.Tx,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.ExpiryTimestamp,
		arg.FailReason,
		arg.StageCode,
	)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (intent_id, pubkey, onchain_address, amount)
VALUES (?1, ?2, ?3, ?4)
ON CONFLICT(intent_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	IntentID       string
	Pubkey         sql.NullString
	OnchainAddress string
	Amount         int64
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.IntentID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id, starting_timestamp, ending_timestamp, ended, failed, fail_reason,
    stage_code, connector_address, version, swept, vtxo_tree_expiration
) VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6,
    ?7, ?8, ?9, ?10, ?11
)
ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code,
    connector_address = EXCLUDED.connector_address,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept,
    vtxo_tree_expiration = EXCLUDED.vtxo_tree_expiration
`

type UpsertRoundParams struct {
	ID                 string
	StartingTimestamp  int64
	EndingTimestamp    int64
	Ended              bool
	Failed             bool
	FailReason         sql.NullString
	StageCode          int64
	ConnectorAddress   string
	Version            int64
	Swept              bool
	VtxoTreeExpiration int64
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.FailReason,
		arg.StageCode,
		arg.ConnectorAddress,
		arg.Version,
		arg.Swept,
		arg.VtxoTreeExpiration,
	)
	return err
}

const upsertScheduledSession = `-- name: UpsertScheduledSession :exec
INSERT INTO scheduled_session (id, start_time, end_time, period, duration, round_min_participants, round_max_participants, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
ON CONFLICT (id) DO UPDATE SET
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    period = EXCLUDED.period,
    duration = EXCLUDED.duration,
    round_min_participants = EXCLUDED.round_min_participants,
    round_max_participants = EXCLUDED.round_max_participants,
    updated_at = EXCLUDED.updated_at
`

type UpsertScheduledSessionParams struct {
	ID                   int64
	StartTime            int64
	EndTime              int64
	Period               int64
	Duration             int64
	RoundMinParticipants int64
	RoundMaxParticipants int64
	UpdatedAt            int64
}

func (q *Queries) UpsertScheduledSession(ctx context.Context, arg UpsertScheduledSessionParams) error {
	_, err := q.db.ExecContext(ctx, upsertScheduledSession,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.Duration,
		arg.RoundMinParticipants,
		arg.RoundMaxParticipants,
		arg.UpdatedAt,
	)
	return err
}

const upsertSettings = `-- name: UpsertSettings :exec
INSERT INTO settings (
    id, ban_threshold, ban_duration,
    unilateral_exit_delay, public_unilateral_exit_delay,
    checkpoint_exit_delay, boarding_exit_delay,
    vtxo_tree_expiry,
    round_min_participants_count, round_max_participants_count,
    vtxo_min_amount, vtxo_max_amount,
    utxo_min_amount, utxo_max_amount,
    settlement_min_expiry_gap,
    vtxo_no_csv_validation_cutoff_date,
    max_tx_weight, updated_at
) VALUES (
    ?1, ?2, ?3,
    ?4, ?5,
    ?6, ?7,
    ?8,
    ?9, ?10,
    ?11, ?12,
    ?13, ?14,
    ?15,
    ?16,
    ?17, ?18
)
ON CONFLICT(id) DO UPDATE SET
    ban_threshold = EXCLUDED.ban_threshold,
    ban_duration = EXCLUDED.ban_duration,
    unilateral_exit_delay = EXCLUDED.unilateral_exit_delay,
    public_unilateral_exit_delay = EXCLUDED.public_unilateral_exit_delay,
    checkpoint_exit_delay = EXCLUDED.checkpoint_exit_delay,
    boarding_exit_delay = EXCLUDED.boarding_exit_delay,
    vtxo_tree_expiry = EXCLUDED.vtxo_tree_expiry,
    round_min_participants_count = EXCLUDED.round_min_participants_count,
    round_max_participants_count = EXCLUDED.round_max_participants_count,
    vtxo_min_amount = EXCLUDED.vtxo_min_amount,
    vtxo_max_amount = EXCLUDED.vtxo_max_amount,
    utxo_min_amount = EXCLUDED.utxo_min_amount,
    utxo_max_amount = EXCLUDED.utxo_max_amount,
    settlement_min_expiry_gap = EXCLUDED.settlement_min_expiry_gap,
    vtxo_no_csv_validation_cutoff_date = EXCLUDED.vtxo_no_csv_validation_cutoff_date,
    max_tx_weight = EXCLUDED.max_tx_weight,
    updated_at = EXCLUDED.updated_at
`

type UpsertSettingsParams struct {
	ID                            int64
	BanThreshold                  int64
	BanDuration                   int64
	UnilateralExitDelay           int64
	PublicUnilateralExitDelay     int64
	CheckpointExitDelay           int64
	BoardingExitDelay             int64
	VtxoTreeExpiry                int64
	RoundMinParticipantsCount     int64
	RoundMaxParticipantsCount     int64
	VtxoMinAmount                 int64
	VtxoMaxAmount                 int64
	UtxoMinAmount                 int64
	UtxoMaxAmount                 int64
	SettlementMinExpiryGap        int64
	VtxoNoCsvValidationCutoffDate int64
	MaxTxWeight                   int64
	UpdatedAt                     int64
}

func (q *Queries) UpsertSettings(ctx context.Context, arg UpsertSettingsParams) error {
	_, err := q.db.ExecContext(ctx, upsertSettings,
		arg.ID,
		arg.BanThreshold,
		arg.BanDuration,
		arg.UnilateralExitDelay,
		arg.PublicUnilateralExitDelay,
		arg.CheckpointExitDelay,
		arg.BoardingExitDelay,
		arg.VtxoTreeExpiry,
		arg.RoundMinParticipantsCount,
		arg.RoundMaxParticipantsCount,
		arg.VtxoMinAmount,
		arg.VtxoMaxAmount,
		arg.UtxoMinAmount,
		arg.UtxoMaxAmount,
		arg.SettlementMinExpiryGap,
		arg.VtxoNoCsvValidationCutoffDate,
		arg.MaxTxWeight,
		arg.UpdatedAt,
	)
	return err
}

const upsertTx = `-- name: UpsertTx :exec
INSERT INTO tx (tx, round_id, type, position, txid, children)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    children = EXCLUDED.children
`

type UpsertTxParams struct {
	Tx       string
	RoundID  string
	Type     string
	Position int64
	Txid     string
	Children sql.NullString
}

func (q *Queries) UpsertTx(ctx context.Context, arg UpsertTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertTx,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.Children,
	)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (
    txid, vout, pubkey, amount, commitment_txid, settled_by, ark_txid,
    spent_by, spent, unrolled, swept, preconfirmed, expires_at, created_at, updated_at
)
VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6, ?7,
    ?8, ?9, ?10, ?11, ?12, ?13, ?14, (CAST((strftime('%s','now') || substr(strftime('%f','now'),4,3)) AS INTEGER))
) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    commitment_txid = EXCLUDED.commitment_txid,
    settled_by = EXCLUDED.settled_by,
    ark_txid = EXCLUDED.ark_txid,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    unrolled = EXCLUDED.unrolled,
    swept = EXCLUDED.swept,
    preconfirmed = EXCLUDED.preconfirmed,
    expires_at = EXCLUDED.expires_at,
    created_at = EXCLUDED.created_at,
    updated_at = (CAST((strftime('%s','now') || substr(strftime('%f','now'),4,3)) AS INTEGER))
`

type UpsertVtxoParams struct {
	Txid           string
	Vout           int64
	Pubkey         string
	Amount         int64
	CommitmentTxid string
	SettledBy      sql.NullString
	ArkTxid        sql.NullString
	SpentBy        sql.NullString
	Spent          bool
	Unrolled       bool
	Swept          bool
	Preconfirmed   bool
	ExpiresAt      int64
	CreatedAt      int64
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.CommitmentTxid,
		arg.SettledBy,
		arg.ArkTxid,
		arg.SpentBy,
		arg.Spent,
		arg.Unrolled,
		arg.Swept,
		arg.Preconfirmed,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}
