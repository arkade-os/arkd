// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package queries

import (
	"context"
	"database/sql"
	"strings"
)

const clearScheduledSession = `-- name: ClearScheduledSession :exec
DELETE FROM scheduled_session
`

func (q *Queries) ClearScheduledSession(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, clearScheduledSession)
	return err
}

const insertVtxoCommitmentTxid = `-- name: InsertVtxoCommitmentTxid :exec
INSERT INTO vtxo_commitment_txid (vtxo_txid, vtxo_vout, commitment_txid)
VALUES (?1, ?2, ?3)
`

type InsertVtxoCommitmentTxidParams struct {
	VtxoTxid       string `json:"vtxo_txid"`
	VtxoVout       int64  `json:"vtxo_vout"`
	CommitmentTxid string `json:"commitment_txid"`
}

func (q *Queries) InsertVtxoCommitmentTxid(ctx context.Context, arg InsertVtxoCommitmentTxidParams) error {
	_, err := q.db.ExecContext(ctx, insertVtxoCommitmentTxid, arg.VtxoTxid, arg.VtxoVout, arg.CommitmentTxid)
	return err
}

const selectActiveScriptConvictions = `-- name: SelectActiveScriptConvictions :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE script = ?1 
AND pardoned = false 
AND (expires_at IS NULL OR expires_at > ?2)
ORDER BY created_at ASC
`

type SelectActiveScriptConvictionsParams struct {
	Script    sql.NullString `json:"script"`
	ExpiresAt sql.NullInt64  `json:"expires_at"`
}

func (q *Queries) SelectActiveScriptConvictions(ctx context.Context, arg SelectActiveScriptConvictionsParams) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectActiveScriptConvictions, arg.Script, arg.ExpiresAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllRoundIds = `-- name: SelectAllRoundIds :many
SELECT id FROM round
`

func (q *Queries) SelectAllRoundIds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectAllRoundIds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAllVtxos = `-- name: SelectAllVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw
`

type SelectAllVtxosRow struct {
	VtxoVw VtxoVw `json:"vtxo_vw"`
}

func (q *Queries) SelectAllVtxos(ctx context.Context) ([]SelectAllVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectAllVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectAllVtxosRow
	for rows.Next() {
		var i SelectAllVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectConviction = `-- name: SelectConviction :one
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction WHERE id = ?1
`

func (q *Queries) SelectConviction(ctx context.Context, id string) (Conviction, error) {
	row := q.db.QueryRowContext(ctx, selectConviction, id)
	var i Conviction
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.CrimeType,
		&i.CrimeRoundID,
		&i.CrimeReason,
		&i.Pardoned,
		&i.Script,
	)
	return i, err
}

const selectConvictionsByRoundID = `-- name: SelectConvictionsByRoundID :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE crime_round_id = ?1
ORDER BY created_at ASC
`

func (q *Queries) SelectConvictionsByRoundID(ctx context.Context, roundID string) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectConvictionsByRoundID, roundID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectConvictionsInTimeRange = `-- name: SelectConvictionsInTimeRange :many
SELECT id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script FROM conviction 
WHERE created_at >= ?1 AND created_at <= ?2
ORDER BY created_at ASC
`

type SelectConvictionsInTimeRangeParams struct {
	FromTime int64 `json:"from_time"`
	ToTime   int64 `json:"to_time"`
}

func (q *Queries) SelectConvictionsInTimeRange(ctx context.Context, arg SelectConvictionsInTimeRangeParams) ([]Conviction, error) {
	rows, err := q.db.QueryContext(ctx, selectConvictionsInTimeRange, arg.FromTime, arg.ToTime)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Conviction
	for rows.Next() {
		var i Conviction
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.CreatedAt,
			&i.ExpiresAt,
			&i.CrimeType,
			&i.CrimeRoundID,
			&i.CrimeReason,
			&i.Pardoned,
			&i.Script,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectLatestScheduledSession = `-- name: SelectLatestScheduledSession :one
SELECT id, start_time, end_time, period, duration, round_min_participants, round_max_participants, updated_at FROM scheduled_session ORDER BY updated_at DESC LIMIT 1
`

func (q *Queries) SelectLatestScheduledSession(ctx context.Context) (ScheduledSession, error) {
	row := q.db.QueryRowContext(ctx, selectLatestScheduledSession)
	var i ScheduledSession
	err := row.Scan(
		&i.ID,
		&i.StartTime,
		&i.EndTime,
		&i.Period,
		&i.Duration,
		&i.RoundMinParticipants,
		&i.RoundMaxParticipants,
		&i.UpdatedAt,
	)
	return i, err
}

const selectNotUnrolledVtxos = `-- name: SelectNotUnrolledVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE unrolled = false
`

type SelectNotUnrolledVtxosRow struct {
	VtxoVw VtxoVw `json:"vtxo_vw"`
}

func (q *Queries) SelectNotUnrolledVtxos(ctx context.Context) ([]SelectNotUnrolledVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectNotUnrolledVtxosWithPubkey = `-- name: SelectNotUnrolledVtxosWithPubkey :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE unrolled = false AND pubkey = ?1
`

type SelectNotUnrolledVtxosWithPubkeyRow struct {
	VtxoVw VtxoVw `json:"vtxo_vw"`
}

func (q *Queries) SelectNotUnrolledVtxosWithPubkey(ctx context.Context, pubkey string) ([]SelectNotUnrolledVtxosWithPubkeyRow, error) {
	rows, err := q.db.QueryContext(ctx, selectNotUnrolledVtxosWithPubkey, pubkey)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectNotUnrolledVtxosWithPubkeyRow
	for rows.Next() {
		var i SelectNotUnrolledVtxosWithPubkeyRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectOffchainTx = `-- name: SelectOffchainTx :many
SELECT  offchain_tx_vw.txid, offchain_tx_vw.tx, offchain_tx_vw.starting_timestamp, offchain_tx_vw.ending_timestamp, offchain_tx_vw.expiry_timestamp, offchain_tx_vw.fail_reason, offchain_tx_vw.stage_code, offchain_tx_vw.checkpoint_txid, offchain_tx_vw.checkpoint_tx, offchain_tx_vw.commitment_txid, offchain_tx_vw.is_root_commitment_txid, offchain_tx_vw.offchain_txid FROM offchain_tx_vw WHERE txid = ?1
`

type SelectOffchainTxRow struct {
	OffchainTxVw OffchainTxVw `json:"offchain_tx_vw"`
}

func (q *Queries) SelectOffchainTx(ctx context.Context, txid string) ([]SelectOffchainTxRow, error) {
	rows, err := q.db.QueryContext(ctx, selectOffchainTx, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectOffchainTxRow
	for rows.Next() {
		var i SelectOffchainTxRow
		if err := rows.Scan(
			&i.OffchainTxVw.Txid,
			&i.OffchainTxVw.Tx,
			&i.OffchainTxVw.StartingTimestamp,
			&i.OffchainTxVw.EndingTimestamp,
			&i.OffchainTxVw.ExpiryTimestamp,
			&i.OffchainTxVw.FailReason,
			&i.OffchainTxVw.StageCode,
			&i.OffchainTxVw.CheckpointTxid,
			&i.OffchainTxVw.CheckpointTx,
			&i.OffchainTxVw.CommitmentTxid,
			&i.OffchainTxVw.IsRootCommitmentTxid,
			&i.OffchainTxVw.OffchainTxid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundConnectors = `-- name: SelectRoundConnectors :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
) AND t.type = 'connector'
`

func (q *Queries) SelectRoundConnectors(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundConnectors, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundForfeitTxs = `-- name: SelectRoundForfeitTxs :many
SELECT t.txid, t.tx, t.round_id, t.type, t.position, t.children FROM tx t WHERE t.round_id IN (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
) AND t.type = 'forfeit'
`

func (q *Queries) SelectRoundForfeitTxs(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundForfeitTxs, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInTimeRange = `-- name: SelectRoundIdsInTimeRange :many
SELECT id FROM round WHERE starting_timestamp > ?1 AND starting_timestamp < ?2
`

type SelectRoundIdsInTimeRangeParams struct {
	StartTs int64 `json:"start_ts"`
	EndTs   int64 `json:"end_ts"`
}

func (q *Queries) SelectRoundIdsInTimeRange(ctx context.Context, arg SelectRoundIdsInTimeRangeParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInTimeRange, arg.StartTs, arg.EndTs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsInTimeRangeWithFilters = `-- name: SelectRoundIdsInTimeRangeWithFilters :many
SELECT id FROM round 
WHERE starting_timestamp > ?1 
  AND starting_timestamp < ?2
  AND (?3 = 1 OR failed = 0)
  AND (?4 = 1 OR ended = 0)
`

type SelectRoundIdsInTimeRangeWithFiltersParams struct {
	StartTs       int64       `json:"start_ts"`
	EndTs         int64       `json:"end_ts"`
	WithFailed    interface{} `json:"with_failed"`
	WithCompleted interface{} `json:"with_completed"`
}

func (q *Queries) SelectRoundIdsInTimeRangeWithFilters(ctx context.Context, arg SelectRoundIdsInTimeRangeWithFiltersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsInTimeRangeWithFilters,
		arg.StartTs,
		arg.EndTs,
		arg.WithFailed,
		arg.WithCompleted,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundIdsWithFilters = `-- name: SelectRoundIdsWithFilters :many
SELECT id FROM round 
WHERE (?1 = 1 OR failed = 0)
  AND (?2 = 1 OR ended = 0)
`

type SelectRoundIdsWithFiltersParams struct {
	WithFailed    interface{} `json:"with_failed"`
	WithCompleted interface{} `json:"with_completed"`
}

func (q *Queries) SelectRoundIdsWithFilters(ctx context.Context, arg SelectRoundIdsWithFiltersParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundIdsWithFilters, arg.WithFailed, arg.WithCompleted)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var id string
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundStats = `-- name: SelectRoundStats :one
SELECT
    r.swept,
    r.starting_timestamp,
    r.ending_timestamp,
    (
        SELECT COALESCE(SUM(amount), 0) FROM (
            SELECT DISTINCT v2.txid, v2.vout, v2.pubkey, v2.amount, v2.expires_at, v2.created_at, v2.commitment_txid, v2.spent_by, v2.spent, v2.unrolled, v2.swept, v2.preconfirmed, v2.settled_by, v2.ark_txid, v2.intent_id FROM vtxo v2 JOIN intent i2 ON i2.id = v2.intent_id WHERE i2.round_id = r.id
        ) as intent_with_inputs_amount
    ) AS total_forfeit_amount,
    (
        SELECT COALESCE(COUNT(v3.txid), 0) FROM vtxo v3 JOIN intent i3 ON i3.id = v3.intent_id WHERE i3.round_id = r.id
    ) AS total_input_vtxos,
    (
        SELECT COALESCE(SUM(amount), 0) FROM (
            SELECT DISTINCT rr.intent_id, rr.pubkey, rr.onchain_address, rr.amount FROM receiver rr
            JOIN intent i4 ON i4.id = rr.intent_id
            WHERE i4.round_id = r.id AND COALESCE(rr.onchain_address, '') = ''
        ) AS intent_outputs_amount
    ) AS total_batch_amount,
    (
        SELECT COUNT(*) FROM tx t WHERE t.round_id = r.id AND t.type = 'tree' AND TRIM(COALESCE(t.children, '')) = ''
    ) AS total_output_vtxos,
    (
        SELECT MAX(v.expires_at) FROM vtxo_vw v WHERE v.commitment_txid = r.txid
    ) AS expires_at
FROM round_with_commitment_tx_vw r
WHERE r.txid = ?1
`

type SelectRoundStatsRow struct {
	Swept              bool        `json:"swept"`
	StartingTimestamp  int64       `json:"starting_timestamp"`
	EndingTimestamp    int64       `json:"ending_timestamp"`
	TotalForfeitAmount interface{} `json:"total_forfeit_amount"`
	TotalInputVtxos    interface{} `json:"total_input_vtxos"`
	TotalBatchAmount   interface{} `json:"total_batch_amount"`
	TotalOutputVtxos   int64       `json:"total_output_vtxos"`
	ExpiresAt          interface{} `json:"expires_at"`
}

func (q *Queries) SelectRoundStats(ctx context.Context, txid string) (SelectRoundStatsRow, error) {
	row := q.db.QueryRowContext(ctx, selectRoundStats, txid)
	var i SelectRoundStatsRow
	err := row.Scan(
		&i.Swept,
		&i.StartingTimestamp,
		&i.EndingTimestamp,
		&i.TotalForfeitAmount,
		&i.TotalInputVtxos,
		&i.TotalBatchAmount,
		&i.TotalOutputVtxos,
		&i.ExpiresAt,
	)
	return i, err
}

const selectRoundVtxoTree = `-- name: SelectRoundVtxoTree :many
SELECT txid, tx, round_id, type, position, children FROM tx WHERE round_id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
) AND type = 'tree'
`

func (q *Queries) SelectRoundVtxoTree(ctx context.Context, txid string) ([]Tx, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTree, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Tx
	for rows.Next() {
		var i Tx
		if err := rows.Scan(
			&i.Txid,
			&i.Tx,
			&i.RoundID,
			&i.Type,
			&i.Position,
			&i.Children,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundVtxoTreeLeaves = `-- name: SelectRoundVtxoTreeLeaves :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE commitment_txid = ?1 AND preconfirmed = false
`

type SelectRoundVtxoTreeLeavesRow struct {
	VtxoVw VtxoVw `json:"vtxo_vw"`
}

func (q *Queries) SelectRoundVtxoTreeLeaves(ctx context.Context, commitmentTxid string) ([]SelectRoundVtxoTreeLeavesRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundVtxoTreeLeaves, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundVtxoTreeLeavesRow
	for rows.Next() {
		var i SelectRoundVtxoTreeLeavesRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithId = `-- name: SelectRoundWithId :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children,
    intent_with_receivers_vw.intent_id, intent_with_receivers_vw.pubkey, intent_with_receivers_vw.onchain_address, intent_with_receivers_vw.amount, intent_with_receivers_vw.id, intent_with_receivers_vw.round_id, intent_with_receivers_vw.proof, intent_with_receivers_vw.message,
    intent_with_inputs_vw.txid, intent_with_inputs_vw.vout, intent_with_inputs_vw.pubkey, intent_with_inputs_vw.amount, intent_with_inputs_vw.expires_at, intent_with_inputs_vw.created_at, intent_with_inputs_vw.commitment_txid, intent_with_inputs_vw.spent_by, intent_with_inputs_vw.spent, intent_with_inputs_vw.unrolled, intent_with_inputs_vw.swept, intent_with_inputs_vw.preconfirmed, intent_with_inputs_vw.settled_by, intent_with_inputs_vw.ark_txid, intent_with_inputs_vw.intent_id, intent_with_inputs_vw.commitments, intent_with_inputs_vw.id, intent_with_inputs_vw.round_id, intent_with_inputs_vw.proof, intent_with_inputs_vw.message
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
LEFT OUTER JOIN intent_with_receivers_vw ON round_intents_vw.id=intent_with_receivers_vw.intent_id
LEFT OUTER JOIN intent_with_inputs_vw ON round_intents_vw.id=intent_with_inputs_vw.intent_id
WHERE round.id = ?1
`

type SelectRoundWithIdRow struct {
	Round                 Round                 `json:"round"`
	RoundIntentsVw        RoundIntentsVw        `json:"round_intents_vw"`
	RoundTxsVw            RoundTxsVw            `json:"round_txs_vw"`
	IntentWithReceiversVw IntentWithReceiversVw `json:"intent_with_receivers_vw"`
	IntentWithInputsVw    IntentWithInputsVw    `json:"intent_with_inputs_vw"`
}

func (q *Queries) SelectRoundWithId(ctx context.Context, id string) ([]SelectRoundWithIdRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithId, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithIdRow
	for rows.Next() {
		var i SelectRoundWithIdRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
			&i.IntentWithReceiversVw.IntentID,
			&i.IntentWithReceiversVw.Pubkey,
			&i.IntentWithReceiversVw.OnchainAddress,
			&i.IntentWithReceiversVw.Amount,
			&i.IntentWithReceiversVw.ID,
			&i.IntentWithReceiversVw.RoundID,
			&i.IntentWithReceiversVw.Proof,
			&i.IntentWithReceiversVw.Message,
			&i.IntentWithInputsVw.Txid,
			&i.IntentWithInputsVw.Vout,
			&i.IntentWithInputsVw.Pubkey,
			&i.IntentWithInputsVw.Amount,
			&i.IntentWithInputsVw.ExpiresAt,
			&i.IntentWithInputsVw.CreatedAt,
			&i.IntentWithInputsVw.CommitmentTxid,
			&i.IntentWithInputsVw.SpentBy,
			&i.IntentWithInputsVw.Spent,
			&i.IntentWithInputsVw.Unrolled,
			&i.IntentWithInputsVw.Swept,
			&i.IntentWithInputsVw.Preconfirmed,
			&i.IntentWithInputsVw.SettledBy,
			&i.IntentWithInputsVw.ArkTxid,
			&i.IntentWithInputsVw.IntentID,
			&i.IntentWithInputsVw.Commitments,
			&i.IntentWithInputsVw.ID,
			&i.IntentWithInputsVw.RoundID,
			&i.IntentWithInputsVw.Proof,
			&i.IntentWithInputsVw.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundWithTxid = `-- name: SelectRoundWithTxid :many
SELECT round.id, round.starting_timestamp, round.ending_timestamp, round.ended, round.failed, round.stage_code, round.connector_address, round.version, round.swept, round.vtxo_tree_expiration, round.fail_reason,
    round_intents_vw.id, round_intents_vw.round_id, round_intents_vw.proof, round_intents_vw.message,
    round_txs_vw.txid, round_txs_vw.tx, round_txs_vw.round_id, round_txs_vw.type, round_txs_vw.position, round_txs_vw.children,
    intent_with_receivers_vw.intent_id, intent_with_receivers_vw.pubkey, intent_with_receivers_vw.onchain_address, intent_with_receivers_vw.amount, intent_with_receivers_vw.id, intent_with_receivers_vw.round_id, intent_with_receivers_vw.proof, intent_with_receivers_vw.message,
    intent_with_inputs_vw.txid, intent_with_inputs_vw.vout, intent_with_inputs_vw.pubkey, intent_with_inputs_vw.amount, intent_with_inputs_vw.expires_at, intent_with_inputs_vw.created_at, intent_with_inputs_vw.commitment_txid, intent_with_inputs_vw.spent_by, intent_with_inputs_vw.spent, intent_with_inputs_vw.unrolled, intent_with_inputs_vw.swept, intent_with_inputs_vw.preconfirmed, intent_with_inputs_vw.settled_by, intent_with_inputs_vw.ark_txid, intent_with_inputs_vw.intent_id, intent_with_inputs_vw.commitments, intent_with_inputs_vw.id, intent_with_inputs_vw.round_id, intent_with_inputs_vw.proof, intent_with_inputs_vw.message
FROM round
LEFT OUTER JOIN round_intents_vw ON round.id=round_intents_vw.round_id
LEFT OUTER JOIN round_txs_vw ON round.id=round_txs_vw.round_id
LEFT OUTER JOIN intent_with_receivers_vw ON round_intents_vw.id=intent_with_receivers_vw.intent_id
LEFT OUTER JOIN intent_with_inputs_vw ON round_intents_vw.id=intent_with_inputs_vw.intent_id
WHERE round.id = (
    SELECT tx.round_id FROM tx WHERE tx.txid = ?1 AND type = 'commitment'
)
`

type SelectRoundWithTxidRow struct {
	Round                 Round                 `json:"round"`
	RoundIntentsVw        RoundIntentsVw        `json:"round_intents_vw"`
	RoundTxsVw            RoundTxsVw            `json:"round_txs_vw"`
	IntentWithReceiversVw IntentWithReceiversVw `json:"intent_with_receivers_vw"`
	IntentWithInputsVw    IntentWithInputsVw    `json:"intent_with_inputs_vw"`
}

func (q *Queries) SelectRoundWithTxid(ctx context.Context, txid string) ([]SelectRoundWithTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectRoundWithTxid, txid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectRoundWithTxidRow
	for rows.Next() {
		var i SelectRoundWithTxidRow
		if err := rows.Scan(
			&i.Round.ID,
			&i.Round.StartingTimestamp,
			&i.Round.EndingTimestamp,
			&i.Round.Ended,
			&i.Round.Failed,
			&i.Round.StageCode,
			&i.Round.ConnectorAddress,
			&i.Round.Version,
			&i.Round.Swept,
			&i.Round.VtxoTreeExpiration,
			&i.Round.FailReason,
			&i.RoundIntentsVw.ID,
			&i.RoundIntentsVw.RoundID,
			&i.RoundIntentsVw.Proof,
			&i.RoundIntentsVw.Message,
			&i.RoundTxsVw.Txid,
			&i.RoundTxsVw.Tx,
			&i.RoundTxsVw.RoundID,
			&i.RoundTxsVw.Type,
			&i.RoundTxsVw.Position,
			&i.RoundTxsVw.Children,
			&i.IntentWithReceiversVw.IntentID,
			&i.IntentWithReceiversVw.Pubkey,
			&i.IntentWithReceiversVw.OnchainAddress,
			&i.IntentWithReceiversVw.Amount,
			&i.IntentWithReceiversVw.ID,
			&i.IntentWithReceiversVw.RoundID,
			&i.IntentWithReceiversVw.Proof,
			&i.IntentWithReceiversVw.Message,
			&i.IntentWithInputsVw.Txid,
			&i.IntentWithInputsVw.Vout,
			&i.IntentWithInputsVw.Pubkey,
			&i.IntentWithInputsVw.Amount,
			&i.IntentWithInputsVw.ExpiresAt,
			&i.IntentWithInputsVw.CreatedAt,
			&i.IntentWithInputsVw.CommitmentTxid,
			&i.IntentWithInputsVw.SpentBy,
			&i.IntentWithInputsVw.Spent,
			&i.IntentWithInputsVw.Unrolled,
			&i.IntentWithInputsVw.Swept,
			&i.IntentWithInputsVw.Preconfirmed,
			&i.IntentWithInputsVw.SettledBy,
			&i.IntentWithInputsVw.ArkTxid,
			&i.IntentWithInputsVw.IntentID,
			&i.IntentWithInputsVw.Commitments,
			&i.IntentWithInputsVw.ID,
			&i.IntentWithInputsVw.RoundID,
			&i.IntentWithInputsVw.Proof,
			&i.IntentWithInputsVw.Message,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectRoundsWithTxids = `-- name: SelectRoundsWithTxids :many
SELECT txid FROM tx WHERE type = 'commitment' AND tx.txid IN (/*SLICE:txids*/?)
`

func (q *Queries) SelectRoundsWithTxids(ctx context.Context, txids []string) ([]string, error) {
	query := selectRoundsWithTxids
	var queryParams []interface{}
	if len(txids) > 0 {
		for _, v := range txids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:txids*/?", strings.Repeat(",?", len(txids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:txids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableRounds = `-- name: SelectSweepableRounds :many
SELECT txid FROM round_with_commitment_tx_vw r 
WHERE r.swept = false AND r.ended = true AND r.failed = false
AND EXISTS (
    SELECT 1 FROM tx tree_tx 
    WHERE tree_tx.round_id = r.id AND tree_tx.type = 'tree'
)
`

func (q *Queries) SelectSweepableRounds(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableRounds)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var txid string
		if err := rows.Scan(&txid); err != nil {
			return nil, err
		}
		items = append(items, txid)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableUnrolledVtxos = `-- name: SelectSweepableUnrolledVtxos :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE spent = true AND unrolled = true AND swept = false AND (COALESCE(settled_by, '') = '')
`

type SelectSweepableUnrolledVtxosRow struct {
	VtxoVw VtxoVw `json:"vtxo_vw"`
}

func (q *Queries) SelectSweepableUnrolledVtxos(ctx context.Context) ([]SelectSweepableUnrolledVtxosRow, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableUnrolledVtxos)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectSweepableUnrolledVtxosRow
	for rows.Next() {
		var i SelectSweepableUnrolledVtxosRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweepableVtxoTapKeys = `-- name: SelectSweepableVtxoTapKeys :many
SELECT DISTINCT pubkey FROM vtxo WHERE unrolled = false AND swept = false
`

func (q *Queries) SelectSweepableVtxoTapKeys(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweepableVtxoTapKeys)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var pubkey string
		if err := rows.Scan(&pubkey); err != nil {
			return nil, err
		}
		items = append(items, pubkey)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSweptRoundsConnectorAddress = `-- name: SelectSweptRoundsConnectorAddress :many
SELECT round.connector_address FROM round
WHERE round.swept = true AND round.failed = false AND round.ended = true AND round.connector_address <> ''
`

func (q *Queries) SelectSweptRoundsConnectorAddress(ctx context.Context) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectSweptRoundsConnectorAddress)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var connector_address string
		if err := rows.Scan(&connector_address); err != nil {
			return nil, err
		}
		items = append(items, connector_address)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectTxs = `-- name: SelectTxs :many
SELECT tx.txid, tx.tx AS data FROM tx WHERE tx.txid IN (/*SLICE:ids1*/?)
UNION
SELECT offchain_tx.txid, offchain_tx.tx AS data FROM offchain_tx WHERE offchain_tx.txid IN (/*SLICE:ids2*/?)
UNION
SELECT checkpoint_tx.txid, checkpoint_tx.tx AS data FROM checkpoint_tx WHERE checkpoint_tx.txid IN (/*SLICE:ids3*/?)
`

type SelectTxsParams struct {
	Ids1 []string `json:"ids1"`
	Ids2 []string `json:"ids2"`
	Ids3 []string `json:"ids3"`
}

type SelectTxsRow struct {
	Txid string `json:"txid"`
	Data string `json:"data"`
}

func (q *Queries) SelectTxs(ctx context.Context, arg SelectTxsParams) ([]SelectTxsRow, error) {
	query := selectTxs
	var queryParams []interface{}
	if len(arg.Ids1) > 0 {
		for _, v := range arg.Ids1 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids1*/?", strings.Repeat(",?", len(arg.Ids1))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids1*/?", "NULL", 1)
	}
	if len(arg.Ids2) > 0 {
		for _, v := range arg.Ids2 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids2*/?", strings.Repeat(",?", len(arg.Ids2))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids2*/?", "NULL", 1)
	}
	if len(arg.Ids3) > 0 {
		for _, v := range arg.Ids3 {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids3*/?", strings.Repeat(",?", len(arg.Ids3))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids3*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectTxsRow
	for rows.Next() {
		var i SelectTxsRow
		if err := rows.Scan(&i.Txid, &i.Data); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectUnsweptVtxoOutpointsByCommitmentTxid = `-- name: SelectUnsweptVtxoOutpointsByCommitmentTxid :many
SELECT DISTINCT vct.vtxo_txid, vct.vtxo_vout 
FROM vtxo_commitment_txid vct
INNER JOIN vtxo v ON vct.vtxo_txid = v.txid AND vct.vtxo_vout = v.vout
WHERE vct.commitment_txid = ?1 AND v.swept = false
`

type SelectUnsweptVtxoOutpointsByCommitmentTxidRow struct {
	VtxoTxid string `json:"vtxo_txid"`
	VtxoVout int64  `json:"vtxo_vout"`
}

func (q *Queries) SelectUnsweptVtxoOutpointsByCommitmentTxid(ctx context.Context, commitmentTxid string) ([]SelectUnsweptVtxoOutpointsByCommitmentTxidRow, error) {
	rows, err := q.db.QueryContext(ctx, selectUnsweptVtxoOutpointsByCommitmentTxid, commitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectUnsweptVtxoOutpointsByCommitmentTxidRow
	for rows.Next() {
		var i SelectUnsweptVtxoOutpointsByCommitmentTxidRow
		if err := rows.Scan(&i.VtxoTxid, &i.VtxoVout); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxo = `-- name: SelectVtxo :one
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE txid = ?1 AND vout = ?2
`

type SelectVtxoParams struct {
	Txid string `json:"txid"`
	Vout int64  `json:"vout"`
}

type SelectVtxoRow struct {
	VtxoVw VtxoVw `json:"vtxo_vw"`
}

func (q *Queries) SelectVtxo(ctx context.Context, arg SelectVtxoParams) (SelectVtxoRow, error) {
	row := q.db.QueryRowContext(ctx, selectVtxo, arg.Txid, arg.Vout)
	var i SelectVtxoRow
	err := row.Scan(
		&i.VtxoVw.Txid,
		&i.VtxoVw.Vout,
		&i.VtxoVw.Pubkey,
		&i.VtxoVw.Amount,
		&i.VtxoVw.ExpiresAt,
		&i.VtxoVw.CreatedAt,
		&i.VtxoVw.CommitmentTxid,
		&i.VtxoVw.SpentBy,
		&i.VtxoVw.Spent,
		&i.VtxoVw.Unrolled,
		&i.VtxoVw.Swept,
		&i.VtxoVw.Preconfirmed,
		&i.VtxoVw.SettledBy,
		&i.VtxoVw.ArkTxid,
		&i.VtxoVw.IntentID,
		&i.VtxoVw.Commitments,
	)
	return i, err
}

const selectVtxoTaprootKeys = `-- name: SelectVtxoTaprootKeys :many
SELECT DISTINCT v.pubkey
FROM vtxo v
WHERE v.amount > ?1
  AND (v.commitment_txid = ?2
    OR EXISTS (
      SELECT 1 FROM vtxo_commitment_txid vct
      WHERE vct.vtxo_txid = v.txid
        AND vct.vtxo_vout = v.vout
        AND vct.commitment_txid = ?2
    ))
`

type SelectVtxoTaprootKeysParams struct {
	MinAmount      int64  `json:"min_amount"`
	CommitmentTxid string `json:"commitment_txid"`
}

func (q *Queries) SelectVtxoTaprootKeys(ctx context.Context, arg SelectVtxoTaprootKeysParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, selectVtxoTaprootKeys, arg.MinAmount, arg.CommitmentTxid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var pubkey string
		if err := rows.Scan(&pubkey); err != nil {
			return nil, err
		}
		items = append(items, pubkey)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectVtxosWithPubkeys = `-- name: SelectVtxosWithPubkeys :many
SELECT vtxo_vw.txid, vtxo_vw.vout, vtxo_vw.pubkey, vtxo_vw.amount, vtxo_vw.expires_at, vtxo_vw.created_at, vtxo_vw.commitment_txid, vtxo_vw.spent_by, vtxo_vw.spent, vtxo_vw.unrolled, vtxo_vw.swept, vtxo_vw.preconfirmed, vtxo_vw.settled_by, vtxo_vw.ark_txid, vtxo_vw.intent_id, vtxo_vw.commitments FROM vtxo_vw WHERE pubkey IN (/*SLICE:pubkey*/?)
`

type SelectVtxosWithPubkeysRow struct {
	VtxoVw VtxoVw `json:"vtxo_vw"`
}

func (q *Queries) SelectVtxosWithPubkeys(ctx context.Context, pubkey []string) ([]SelectVtxosWithPubkeysRow, error) {
	query := selectVtxosWithPubkeys
	var queryParams []interface{}
	if len(pubkey) > 0 {
		for _, v := range pubkey {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:pubkey*/?", strings.Repeat(",?", len(pubkey))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:pubkey*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectVtxosWithPubkeysRow
	for rows.Next() {
		var i SelectVtxosWithPubkeysRow
		if err := rows.Scan(
			&i.VtxoVw.Txid,
			&i.VtxoVw.Vout,
			&i.VtxoVw.Pubkey,
			&i.VtxoVw.Amount,
			&i.VtxoVw.ExpiresAt,
			&i.VtxoVw.CreatedAt,
			&i.VtxoVw.CommitmentTxid,
			&i.VtxoVw.SpentBy,
			&i.VtxoVw.Spent,
			&i.VtxoVw.Unrolled,
			&i.VtxoVw.Swept,
			&i.VtxoVw.Preconfirmed,
			&i.VtxoVw.SettledBy,
			&i.VtxoVw.ArkTxid,
			&i.VtxoVw.IntentID,
			&i.VtxoVw.Commitments,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateConvictionPardoned = `-- name: UpdateConvictionPardoned :exec
UPDATE conviction SET pardoned = true WHERE id = ?1
`

func (q *Queries) UpdateConvictionPardoned(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, updateConvictionPardoned, id)
	return err
}

const updateVtxoExpiration = `-- name: UpdateVtxoExpiration :exec
UPDATE vtxo SET expires_at = ?1 WHERE txid = ?2 AND vout = ?3
`

type UpdateVtxoExpirationParams struct {
	ExpiresAt int64  `json:"expires_at"`
	Txid      string `json:"txid"`
	Vout      int64  `json:"vout"`
}

func (q *Queries) UpdateVtxoExpiration(ctx context.Context, arg UpdateVtxoExpirationParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoExpiration, arg.ExpiresAt, arg.Txid, arg.Vout)
	return err
}

const updateVtxoIntentId = `-- name: UpdateVtxoIntentId :exec
UPDATE vtxo SET intent_id = ?1 WHERE txid = ?2 AND vout = ?3
`

type UpdateVtxoIntentIdParams struct {
	IntentID sql.NullString `json:"intent_id"`
	Txid     string         `json:"txid"`
	Vout     int64          `json:"vout"`
}

func (q *Queries) UpdateVtxoIntentId(ctx context.Context, arg UpdateVtxoIntentIdParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoIntentId, arg.IntentID, arg.Txid, arg.Vout)
	return err
}

const updateVtxoSettled = `-- name: UpdateVtxoSettled :exec
UPDATE vtxo SET spent = true, spent_by = ?1, settled_by = ?2
WHERE txid = ?3 AND vout = ?4
`

type UpdateVtxoSettledParams struct {
	SpentBy   sql.NullString `json:"spent_by"`
	SettledBy sql.NullString `json:"settled_by"`
	Txid      string         `json:"txid"`
	Vout      int64          `json:"vout"`
}

func (q *Queries) UpdateVtxoSettled(ctx context.Context, arg UpdateVtxoSettledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSettled,
		arg.SpentBy,
		arg.SettledBy,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoSpent = `-- name: UpdateVtxoSpent :exec
UPDATE vtxo SET spent = true, spent_by = ?1, ark_txid = ?2
WHERE txid = ?3 AND vout = ?4
`

type UpdateVtxoSpentParams struct {
	SpentBy sql.NullString `json:"spent_by"`
	ArkTxid sql.NullString `json:"ark_txid"`
	Txid    string         `json:"txid"`
	Vout    int64          `json:"vout"`
}

func (q *Queries) UpdateVtxoSpent(ctx context.Context, arg UpdateVtxoSpentParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoSpent,
		arg.SpentBy,
		arg.ArkTxid,
		arg.Txid,
		arg.Vout,
	)
	return err
}

const updateVtxoSweptIfNotSwept = `-- name: UpdateVtxoSweptIfNotSwept :execrows
UPDATE vtxo SET swept = true WHERE txid = ?1 AND vout = ?2 AND swept = false
`

type UpdateVtxoSweptIfNotSweptParams struct {
	Txid string `json:"txid"`
	Vout int64  `json:"vout"`
}

func (q *Queries) UpdateVtxoSweptIfNotSwept(ctx context.Context, arg UpdateVtxoSweptIfNotSweptParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateVtxoSweptIfNotSwept, arg.Txid, arg.Vout)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateVtxoUnrolled = `-- name: UpdateVtxoUnrolled :exec
UPDATE vtxo SET unrolled = true WHERE txid = ?1 AND vout = ?2
`

type UpdateVtxoUnrolledParams struct {
	Txid string `json:"txid"`
	Vout int64  `json:"vout"`
}

func (q *Queries) UpdateVtxoUnrolled(ctx context.Context, arg UpdateVtxoUnrolledParams) error {
	_, err := q.db.ExecContext(ctx, updateVtxoUnrolled, arg.Txid, arg.Vout)
	return err
}

const upsertCheckpointTx = `-- name: UpsertCheckpointTx :exec
INSERT INTO checkpoint_tx (txid, tx, commitment_txid, is_root_commitment_txid, offchain_txid)
VALUES (?1, ?2, ?3, ?4, ?5)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    commitment_txid = EXCLUDED.commitment_txid,
    is_root_commitment_txid = EXCLUDED.is_root_commitment_txid,
    offchain_txid = EXCLUDED.offchain_txid
`

type UpsertCheckpointTxParams struct {
	Txid                 string `json:"txid"`
	Tx                   string `json:"tx"`
	CommitmentTxid       string `json:"commitment_txid"`
	IsRootCommitmentTxid bool   `json:"is_root_commitment_txid"`
	OffchainTxid         string `json:"offchain_txid"`
}

func (q *Queries) UpsertCheckpointTx(ctx context.Context, arg UpsertCheckpointTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertCheckpointTx,
		arg.Txid,
		arg.Tx,
		arg.CommitmentTxid,
		arg.IsRootCommitmentTxid,
		arg.OffchainTxid,
	)
	return err
}

const upsertConviction = `-- name: UpsertConviction :exec
INSERT INTO conviction (
    id, type, created_at, expires_at, crime_type, crime_round_id, crime_reason, pardoned, script
) VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8, ?9
)
ON CONFLICT(id) DO UPDATE SET
    pardoned = EXCLUDED.pardoned
`

type UpsertConvictionParams struct {
	ID           string         `json:"id"`
	Type         int64          `json:"type"`
	CreatedAt    int64          `json:"created_at"`
	ExpiresAt    sql.NullInt64  `json:"expires_at"`
	CrimeType    int64          `json:"crime_type"`
	CrimeRoundID string         `json:"crime_round_id"`
	CrimeReason  string         `json:"crime_reason"`
	Pardoned     bool           `json:"pardoned"`
	Script       sql.NullString `json:"script"`
}

func (q *Queries) UpsertConviction(ctx context.Context, arg UpsertConvictionParams) error {
	_, err := q.db.ExecContext(ctx, upsertConviction,
		arg.ID,
		arg.Type,
		arg.CreatedAt,
		arg.ExpiresAt,
		arg.CrimeType,
		arg.CrimeRoundID,
		arg.CrimeReason,
		arg.Pardoned,
		arg.Script,
	)
	return err
}

const upsertIntent = `-- name: UpsertIntent :exec
INSERT INTO intent (id, round_id, proof, message) VALUES (?1, ?2, ?3, ?4)
ON CONFLICT(id) DO UPDATE SET
    round_id = EXCLUDED.round_id,
    proof = EXCLUDED.proof,
    message = EXCLUDED.message
`

type UpsertIntentParams struct {
	ID      sql.NullString `json:"id"`
	RoundID sql.NullString `json:"round_id"`
	Proof   sql.NullString `json:"proof"`
	Message sql.NullString `json:"message"`
}

func (q *Queries) UpsertIntent(ctx context.Context, arg UpsertIntentParams) error {
	_, err := q.db.ExecContext(ctx, upsertIntent,
		arg.ID,
		arg.RoundID,
		arg.Proof,
		arg.Message,
	)
	return err
}

const upsertOffchainTx = `-- name: UpsertOffchainTx :exec
INSERT INTO offchain_tx (txid, tx, starting_timestamp, ending_timestamp, expiry_timestamp, fail_reason, stage_code)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    expiry_timestamp = EXCLUDED.expiry_timestamp,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code
`

type UpsertOffchainTxParams struct {
	Txid              string         `json:"txid"`
	Tx                string         `json:"tx"`
	StartingTimestamp int64          `json:"starting_timestamp"`
	EndingTimestamp   int64          `json:"ending_timestamp"`
	ExpiryTimestamp   int64          `json:"expiry_timestamp"`
	FailReason        sql.NullString `json:"fail_reason"`
	StageCode         int64          `json:"stage_code"`
}

func (q *Queries) UpsertOffchainTx(ctx context.Context, arg UpsertOffchainTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertOffchainTx,
		arg.Txid,
		arg.Tx,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.ExpiryTimestamp,
		arg.FailReason,
		arg.StageCode,
	)
	return err
}

const upsertReceiver = `-- name: UpsertReceiver :exec
INSERT INTO receiver (intent_id, pubkey, onchain_address, amount)
VALUES (?1, ?2, ?3, ?4)
ON CONFLICT(intent_id, pubkey, onchain_address) DO UPDATE SET
    amount = EXCLUDED.amount,
    pubkey = EXCLUDED.pubkey,
    onchain_address = EXCLUDED.onchain_address
`

type UpsertReceiverParams struct {
	IntentID       string         `json:"intent_id"`
	Pubkey         sql.NullString `json:"pubkey"`
	OnchainAddress string         `json:"onchain_address"`
	Amount         int64          `json:"amount"`
}

func (q *Queries) UpsertReceiver(ctx context.Context, arg UpsertReceiverParams) error {
	_, err := q.db.ExecContext(ctx, upsertReceiver,
		arg.IntentID,
		arg.Pubkey,
		arg.OnchainAddress,
		arg.Amount,
	)
	return err
}

const upsertRound = `-- name: UpsertRound :exec
INSERT INTO round (
    id, starting_timestamp, ending_timestamp, ended, failed, fail_reason,
    stage_code, connector_address, version, swept, vtxo_tree_expiration
) VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6,
    ?7, ?8, ?9, ?10, ?11
)
ON CONFLICT(id) DO UPDATE SET
    starting_timestamp = EXCLUDED.starting_timestamp,
    ending_timestamp = EXCLUDED.ending_timestamp,
    ended = EXCLUDED.ended,
    failed = EXCLUDED.failed,
    fail_reason = EXCLUDED.fail_reason,
    stage_code = EXCLUDED.stage_code,
    connector_address = EXCLUDED.connector_address,
    version = EXCLUDED.version,
    swept = EXCLUDED.swept,
    vtxo_tree_expiration = EXCLUDED.vtxo_tree_expiration
`

type UpsertRoundParams struct {
	ID                 string         `json:"id"`
	StartingTimestamp  int64          `json:"starting_timestamp"`
	EndingTimestamp    int64          `json:"ending_timestamp"`
	Ended              bool           `json:"ended"`
	Failed             bool           `json:"failed"`
	FailReason         sql.NullString `json:"fail_reason"`
	StageCode          int64          `json:"stage_code"`
	ConnectorAddress   string         `json:"connector_address"`
	Version            int64          `json:"version"`
	Swept              bool           `json:"swept"`
	VtxoTreeExpiration int64          `json:"vtxo_tree_expiration"`
}

func (q *Queries) UpsertRound(ctx context.Context, arg UpsertRoundParams) error {
	_, err := q.db.ExecContext(ctx, upsertRound,
		arg.ID,
		arg.StartingTimestamp,
		arg.EndingTimestamp,
		arg.Ended,
		arg.Failed,
		arg.FailReason,
		arg.StageCode,
		arg.ConnectorAddress,
		arg.Version,
		arg.Swept,
		arg.VtxoTreeExpiration,
	)
	return err
}

const upsertScheduledSession = `-- name: UpsertScheduledSession :exec
INSERT INTO scheduled_session (id, start_time, end_time, period, duration, round_min_participants, round_max_participants, updated_at)
VALUES (?1, ?2, ?3, ?4, ?5, ?6, ?7, ?8)
ON CONFLICT (id) DO UPDATE SET
    start_time = EXCLUDED.start_time,
    end_time = EXCLUDED.end_time,
    period = EXCLUDED.period,
    duration = EXCLUDED.duration,
    round_min_participants = EXCLUDED.round_min_participants,
    round_max_participants = EXCLUDED.round_max_participants,
    updated_at = EXCLUDED.updated_at
`

type UpsertScheduledSessionParams struct {
	ID                   int64 `json:"id"`
	StartTime            int64 `json:"start_time"`
	EndTime              int64 `json:"end_time"`
	Period               int64 `json:"period"`
	Duration             int64 `json:"duration"`
	RoundMinParticipants int64 `json:"round_min_participants"`
	RoundMaxParticipants int64 `json:"round_max_participants"`
	UpdatedAt            int64 `json:"updated_at"`
}

func (q *Queries) UpsertScheduledSession(ctx context.Context, arg UpsertScheduledSessionParams) error {
	_, err := q.db.ExecContext(ctx, upsertScheduledSession,
		arg.ID,
		arg.StartTime,
		arg.EndTime,
		arg.Period,
		arg.Duration,
		arg.RoundMinParticipants,
		arg.RoundMaxParticipants,
		arg.UpdatedAt,
	)
	return err
}

const upsertTx = `-- name: UpsertTx :exec
INSERT INTO tx (tx, round_id, type, position, txid, children)
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
ON CONFLICT(txid) DO UPDATE SET
    tx = EXCLUDED.tx,
    round_id = EXCLUDED.round_id,
    type = EXCLUDED.type,
    position = EXCLUDED.position,
    txid = EXCLUDED.txid,
    children = EXCLUDED.children
`

type UpsertTxParams struct {
	Tx       string         `json:"tx"`
	RoundID  string         `json:"round_id"`
	Type     string         `json:"type"`
	Position int64          `json:"position"`
	Txid     string         `json:"txid"`
	Children sql.NullString `json:"children"`
}

func (q *Queries) UpsertTx(ctx context.Context, arg UpsertTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertTx,
		arg.Tx,
		arg.RoundID,
		arg.Type,
		arg.Position,
		arg.Txid,
		arg.Children,
	)
	return err
}

const upsertVtxo = `-- name: UpsertVtxo :exec
INSERT INTO vtxo (
    txid, vout, pubkey, amount, commitment_txid, settled_by, ark_txid,
    spent_by, spent, unrolled, swept, preconfirmed, expires_at, created_at
)
VALUES (
    ?1, ?2, ?3, ?4, ?5, ?6, ?7,
    ?8, ?9, ?10, ?11, ?12, ?13, ?14
) ON CONFLICT(txid, vout) DO UPDATE SET
    pubkey = EXCLUDED.pubkey,
    amount = EXCLUDED.amount,
    commitment_txid = EXCLUDED.commitment_txid,
    settled_by = EXCLUDED.settled_by,
    ark_txid = EXCLUDED.ark_txid,
    spent_by = EXCLUDED.spent_by,
    spent = EXCLUDED.spent,
    unrolled = EXCLUDED.unrolled,
    swept = EXCLUDED.swept,
    preconfirmed = EXCLUDED.preconfirmed,
    expires_at = EXCLUDED.expires_at,
    created_at = EXCLUDED.created_at
`

type UpsertVtxoParams struct {
	Txid           string         `json:"txid"`
	Vout           int64          `json:"vout"`
	Pubkey         string         `json:"pubkey"`
	Amount         int64          `json:"amount"`
	CommitmentTxid string         `json:"commitment_txid"`
	SettledBy      sql.NullString `json:"settled_by"`
	ArkTxid        sql.NullString `json:"ark_txid"`
	SpentBy        sql.NullString `json:"spent_by"`
	Spent          bool           `json:"spent"`
	Unrolled       bool           `json:"unrolled"`
	Swept          bool           `json:"swept"`
	Preconfirmed   bool           `json:"preconfirmed"`
	ExpiresAt      int64          `json:"expires_at"`
	CreatedAt      int64          `json:"created_at"`
}

func (q *Queries) UpsertVtxo(ctx context.Context, arg UpsertVtxoParams) error {
	_, err := q.db.ExecContext(ctx, upsertVtxo,
		arg.Txid,
		arg.Vout,
		arg.Pubkey,
		arg.Amount,
		arg.CommitmentTxid,
		arg.SettledBy,
		arg.ArkTxid,
		arg.SpentBy,
		arg.Spent,
		arg.Unrolled,
		arg.Swept,
		arg.Preconfirmed,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}
