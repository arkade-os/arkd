// Code generated by protoc-gen-grpc-api-gateway. DO NOT EDIT.
// source: arkwallet/v1/bitcoin_wallet.proto

/*
Package arkwalletv1 is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package arkwalletv1

import (
	"context"
	"io"
	"net/http"

	"github.com/meshapi/grpc-api-gateway/gateway"
	"github.com/meshapi/grpc-api-gateway/trie"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
	"google.golang.org/protobuf/proto"
)

func request_WalletService_GenSeed_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GenSeedRequest
	var metadata gateway.ServerMetadata

	msg, err := client.GenSeed(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_Create_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq CreateRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.Create(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_Restore_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq RestoreRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.Restore(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_Unlock_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq UnlockRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.Unlock(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_Lock_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq LockRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.Lock(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_Status_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq StatusRequest
	var metadata gateway.ServerMetadata

	msg, err := client.Status(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_GetNetwork_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetNetworkRequest
	var metadata gateway.ServerMetadata

	msg, err := client.GetNetwork(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_GetForfeitPubkey_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetForfeitPubkeyRequest
	var metadata gateway.ServerMetadata

	msg, err := client.GetForfeitPubkey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_DeriveConnectorAddress_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq DeriveConnectorAddressRequest
	var metadata gateway.ServerMetadata

	msg, err := client.DeriveConnectorAddress(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_DeriveAddresses_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq DeriveAddressesRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.DeriveAddresses(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_SignTransaction_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq SignTransactionRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.SignTransaction(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_SignTransactionTapscript_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq SignTransactionTapscriptRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.SignTransactionTapscript(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_SelectUtxos_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq SelectUtxosRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.SelectUtxos(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_BroadcastTransaction_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq BroadcastTransactionRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.BroadcastTransaction(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_GetReadyUpdate_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (WalletService_GetReadyUpdateClient, gateway.ServerMetadata, error) {
	var protoReq GetReadyUpdateRequest
	var metadata gateway.ServerMetadata

	stream, err := client.GetReadyUpdate(ctx, &protoReq)
	if err != nil {
		return nil, metadata, err
	}
	header, err := stream.Header()
	if err != nil {
		return nil, metadata, err
	}
	metadata.HeaderMD = header
	return stream, metadata, nil

}

func websocket_WalletService_GetReadyUpdate_0(ctx context.Context, inboundMarshaler, outboundMarshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, w http.ResponseWriter, req *http.Request) {
	var protoReq GetReadyUpdateRequest

	websocketConnection, err := mux.UpgradeToWebsocket(w, req)
	if err != nil {
		grpclog.Infof("Failed to upgrade HTTP request: %v", err)
		return
	}
	closeConnection := func() {
		if err := websocketConnection.Close(); err != nil {
			grpclog.Infof("Failed to close websocket connection: %v", err)
		}
	}
	requestData, err := websocketConnection.ReceiveMessage()
	if err == io.EOF {
		closeConnection()
		return
	}
	if err != nil {
		grpclog.Infof("failed to receive message: %v", err)
		closeConnection()
		return
	}
	if err := inboundMarshaler.Unmarshal(requestData, &protoReq); err != nil {
		grpclog.Infof("Failed to decode request from websocket: %v", err)
		mux.WebsocketError(ctx, outboundMarshaler, req, websocketConnection, gateway.ErrMarshal{Err: err, Inbound: true})
		closeConnection()
		return
	}
	stream, err := client.GetReadyUpdate(ctx, &protoReq)
	if err != nil {
		grpclog.Infof("Failed to start gRPC stream: %v", err)
		mux.WebsocketError(ctx, outboundMarshaler, req, websocketConnection, err)
		closeConnection()
		return
	}
	var protoRes GetReadyUpdateResponse
	mux.ForwardWebsocketServerStreaming(ctx, req, stream, websocketConnection, outboundMarshaler, &protoRes)
}

var (
	query_params_WalletService_IsTransactionConfirmed_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New(),
	}
)

func request_WalletService_IsTransactionConfirmed_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq IsTransactionConfirmedRequest
	var metadata gateway.ServerMetadata

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_WalletService_IsTransactionConfirmed_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.IsTransactionConfirmed(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_WalletService_GetOutpointStatus_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New(),
	}
)

func request_WalletService_GetOutpointStatus_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetOutpointStatusRequest
	var metadata gateway.ServerMetadata

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_WalletService_GetOutpointStatus_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetOutpointStatus(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_EstimateFees_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq EstimateFeesRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.EstimateFees(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_FeeRate_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq FeeRateRequest
	var metadata gateway.ServerMetadata

	msg, err := client.FeeRate(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_WalletService_ListConnectorUtxos_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New(),
	}
)

func request_WalletService_ListConnectorUtxos_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq ListConnectorUtxosRequest
	var metadata gateway.ServerMetadata

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_WalletService_ListConnectorUtxos_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.ListConnectorUtxos(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_MainAccountBalance_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq MainAccountBalanceRequest
	var metadata gateway.ServerMetadata

	msg, err := client.MainAccountBalance(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_ConnectorsAccountBalance_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq ConnectorsAccountBalanceRequest
	var metadata gateway.ServerMetadata

	msg, err := client.ConnectorsAccountBalance(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_LockConnectorUtxos_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq LockConnectorUtxosRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.LockConnectorUtxos(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_GetDustAmount_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetDustAmountRequest
	var metadata gateway.ServerMetadata

	msg, err := client.GetDustAmount(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_WalletService_GetTransaction_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New(),
	}
)

func request_WalletService_GetTransaction_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetTransactionRequest
	var metadata gateway.ServerMetadata

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_WalletService_GetTransaction_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetTransaction(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_SignMessage_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq SignMessageRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.SignMessage(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_VerifyMessageSignature_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq VerifyMessageSignatureRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.VerifyMessageSignature(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_GetCurrentBlockTime_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetCurrentBlockTimeRequest
	var metadata gateway.ServerMetadata

	msg, err := client.GetCurrentBlockTime(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_Withdraw_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq WithdrawRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.Withdraw(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_WatchScripts_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq WatchScriptsRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.WatchScripts(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_UnwatchScripts_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq UnwatchScriptsRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.UnwatchScripts(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_WalletService_NotificationStream_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (WalletService_NotificationStreamClient, gateway.ServerMetadata, error) {
	var protoReq NotificationStreamRequest
	var metadata gateway.ServerMetadata

	stream, err := client.NotificationStream(ctx, &protoReq)
	if err != nil {
		return nil, metadata, err
	}
	header, err := stream.Header()
	if err != nil {
		return nil, metadata, err
	}
	metadata.HeaderMD = header
	return stream, metadata, nil

}

func websocket_WalletService_NotificationStream_0(ctx context.Context, inboundMarshaler, outboundMarshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, w http.ResponseWriter, req *http.Request) {
	var protoReq NotificationStreamRequest

	websocketConnection, err := mux.UpgradeToWebsocket(w, req)
	if err != nil {
		grpclog.Infof("Failed to upgrade HTTP request: %v", err)
		return
	}
	closeConnection := func() {
		if err := websocketConnection.Close(); err != nil {
			grpclog.Infof("Failed to close websocket connection: %v", err)
		}
	}
	requestData, err := websocketConnection.ReceiveMessage()
	if err == io.EOF {
		closeConnection()
		return
	}
	if err != nil {
		grpclog.Infof("failed to receive message: %v", err)
		closeConnection()
		return
	}
	if err := inboundMarshaler.Unmarshal(requestData, &protoReq); err != nil {
		grpclog.Infof("Failed to decode request from websocket: %v", err)
		mux.WebsocketError(ctx, outboundMarshaler, req, websocketConnection, gateway.ErrMarshal{Err: err, Inbound: true})
		closeConnection()
		return
	}
	stream, err := client.NotificationStream(ctx, &protoReq)
	if err != nil {
		grpclog.Infof("Failed to start gRPC stream: %v", err)
		mux.WebsocketError(ctx, outboundMarshaler, req, websocketConnection, err)
		closeConnection()
		return
	}
	var protoRes NotificationStreamResponse
	mux.ForwardWebsocketServerStreaming(ctx, req, stream, websocketConnection, outboundMarshaler, &protoRes)
}

func request_WalletService_LoadSignerKey_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client WalletServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq LoadSignerKeyRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.LoadSignerKey(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

// RegisterWalletServiceHandlerFromEndpoint is same as RegisterWalletServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterWalletServiceHandlerFromEndpoint(ctx context.Context, mux *gateway.ServeMux, endpoint string, opts []grpc.DialOption) error {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	RegisterWalletServiceHandler(ctx, mux, conn)
	return nil
}

// RegisterWalletServiceHandler registers the http handlers for service WalletService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterWalletServiceHandler(ctx context.Context, mux *gateway.ServeMux, conn *grpc.ClientConn) {
	RegisterWalletServiceHandlerClient(ctx, mux, NewWalletServiceClient(conn))
}

// RegisterWalletServiceHandlerClient registers the http handlers for service WalletService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "WalletServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "WalletServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "WalletServiceClient" to call the correct interceptors.
func RegisterWalletServiceHandlerClient(ctx context.Context, mux *gateway.ServeMux, client WalletServiceClient) {

	mux.HandleWithParams("GET", "/v1/wallet/seed", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GenSeed", gateway.WithHTTPPathPattern("/v1/wallet/seed"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_GenSeed_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/create", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/Create", gateway.WithHTTPPathPattern("/v1/wallet/create"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_Create_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/restore", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/Restore", gateway.WithHTTPPathPattern("/v1/wallet/restore"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_Restore_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/unlock", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/Unlock", gateway.WithHTTPPathPattern("/v1/wallet/unlock"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_Unlock_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/lock", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/Lock", gateway.WithHTTPPathPattern("/v1/wallet/lock"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_Lock_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/status", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/Status", gateway.WithHTTPPathPattern("/v1/wallet/status"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_Status_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/network", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GetNetwork", gateway.WithHTTPPathPattern("/v1/wallet/network"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_GetNetwork_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/forfeit-pubkey", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GetForfeitPubkey", gateway.WithHTTPPathPattern("/v1/wallet/forfeit-pubkey"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_GetForfeitPubkey_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/connector-address", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/DeriveConnectorAddress", gateway.WithHTTPPathPattern("/v1/wallet/connector-address"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_DeriveConnectorAddress_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/derive-addresses", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/DeriveAddresses", gateway.WithHTTPPathPattern("/v1/wallet/derive-addresses"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_DeriveAddresses_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/sign-transaction", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/SignTransaction", gateway.WithHTTPPathPattern("/v1/wallet/sign-transaction"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_SignTransaction_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/sign-transaction-tapscript", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/SignTransactionTapscript", gateway.WithHTTPPathPattern("/v1/wallet/sign-transaction-tapscript"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_SignTransactionTapscript_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/select-utxos", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/SelectUtxos", gateway.WithHTTPPathPattern("/v1/wallet/select-utxos"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_SelectUtxos_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/broadcast", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/BroadcastTransaction", gateway.WithHTTPPathPattern("/v1/wallet/broadcast"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_BroadcastTransaction_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/ready-update", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GetReadyUpdate", gateway.WithHTTPPathPattern("/v1/wallet/ready-update"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		if mux.IsWebsocketUpgrade(req) {
			websocket_WalletService_GetReadyUpdate_0(annotatedContext, inboundMarshaler, outboundMarshaler, mux, client, w, req)
			return
		}

		resp, md, err := request_WalletService_GetReadyUpdate_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		if mux.IsSSE(req) {
			mux.ForwardResponseStreamSSE(annotatedContext, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() })
			return
		}

		mux.ForwardResponseStreamChunked(annotatedContext, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() })

	})

	mux.HandleWithParams("GET", "/v1/wallet/transaction-confirmed", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/IsTransactionConfirmed", gateway.WithHTTPPathPattern("/v1/wallet/transaction-confirmed"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_IsTransactionConfirmed_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/outpoint-status", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GetOutpointStatus", gateway.WithHTTPPathPattern("/v1/wallet/outpoint-status"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_GetOutpointStatus_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/estimate-fees", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/EstimateFees", gateway.WithHTTPPathPattern("/v1/wallet/estimate-fees"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_EstimateFees_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/fee-rate", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/FeeRate", gateway.WithHTTPPathPattern("/v1/wallet/fee-rate"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_FeeRate_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/connector-utxos", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/ListConnectorUtxos", gateway.WithHTTPPathPattern("/v1/wallet/connector-utxos"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_ListConnectorUtxos_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/main-account-balance", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/MainAccountBalance", gateway.WithHTTPPathPattern("/v1/wallet/main-account-balance"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_MainAccountBalance_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/connectors-account-balance", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/ConnectorsAccountBalance", gateway.WithHTTPPathPattern("/v1/wallet/connectors-account-balance"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_ConnectorsAccountBalance_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/lock-connector-utxos", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/LockConnectorUtxos", gateway.WithHTTPPathPattern("/v1/wallet/lock-connector-utxos"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_LockConnectorUtxos_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/dust", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GetDustAmount", gateway.WithHTTPPathPattern("/v1/wallet/dust"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_GetDustAmount_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/tx", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GetTransaction", gateway.WithHTTPPathPattern("/v1/wallet/tx"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_GetTransaction_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/sign-message", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/SignMessage", gateway.WithHTTPPathPattern("/v1/wallet/sign-message"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_SignMessage_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/verify-message-signature", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/VerifyMessageSignature", gateway.WithHTTPPathPattern("/v1/wallet/verify-message-signature"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_VerifyMessageSignature_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/block-time", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/GetCurrentBlockTime", gateway.WithHTTPPathPattern("/v1/wallet/block-time"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_GetCurrentBlockTime_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/withdraw", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/Withdraw", gateway.WithHTTPPathPattern("/v1/wallet/withdraw"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_Withdraw_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/watch-scripts", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/WatchScripts", gateway.WithHTTPPathPattern("/v1/wallet/watch-scripts"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_WatchScripts_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/wallet/unwatch-scripts", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/UnwatchScripts", gateway.WithHTTPPathPattern("/v1/wallet/unwatch-scripts"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_UnwatchScripts_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/wallet/notifications", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/NotificationStream", gateway.WithHTTPPathPattern("/v1/wallet/notifications"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		if mux.IsWebsocketUpgrade(req) {
			websocket_WalletService_NotificationStream_0(annotatedContext, inboundMarshaler, outboundMarshaler, mux, client, w, req)
			return
		}

		resp, md, err := request_WalletService_NotificationStream_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		if mux.IsSSE(req) {
			mux.ForwardResponseStreamSSE(annotatedContext, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() })
			return
		}

		mux.ForwardResponseStreamChunked(annotatedContext, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() })

	})

	mux.HandleWithParams("POST", "/v1/wallet/signer-key", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/arkwallet.v1.WalletService/LoadSignerKey", gateway.WithHTTPPathPattern("/v1/wallet/signer-key"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_WalletService_LoadSignerKey_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

}
