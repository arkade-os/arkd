// Code generated by protoc-gen-grpc-api-gateway. DO NOT EDIT.
// source: indexer/v1/service.proto

/*
Package indexerv1 is a reverse proxy.

It translates gRPC into RESTful JSON APIs.
*/
package indexerv1

import (
	"context"
	"io"
	"net/http"

	"github.com/meshapi/grpc-api-gateway/gateway"
	"github.com/meshapi/grpc-api-gateway/protoconvert"
	"github.com/meshapi/grpc-api-gateway/protopath"
	"github.com/meshapi/grpc-api-gateway/trie"
	"google.golang.org/grpc"
	"google.golang.org/grpc/grpclog"
	"google.golang.org/protobuf/proto"
)

func request_IndexerService_GetCommitmentTx_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetCommitmentTxRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("txid")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "txid"}
	}

	protoReq.Txid, err = protoconvert.String(val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "txid"}
	}

	msg, err := client.GetCommitmentTx(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_IndexerService_GetForfeitTxs_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New("txid"),
	}
)

func request_IndexerService_GetForfeitTxs_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetForfeitTxsRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("txid")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "txid"}
	}

	protoReq.Txid, err = protoconvert.String(val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "txid"}
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_IndexerService_GetForfeitTxs_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetForfeitTxs(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_IndexerService_GetConnectors_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New("txid"),
	}
)

func request_IndexerService_GetConnectors_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetConnectorsRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("txid")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "txid"}
	}

	protoReq.Txid, err = protoconvert.String(val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "txid"}
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_IndexerService_GetConnectors_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetConnectors(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_IndexerService_GetVtxoTree_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New("txid", "vout", "batch_outpoint.txid", "batch_outpoint.vout"),
	}
)

func request_IndexerService_GetVtxoTree_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetVtxoTreeRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("batch_outpoint.txid")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "batch_outpoint.txid"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "batch_outpoint.txid", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "batch_outpoint.txid"}
	}

	val = pathParams.ByName("batch_outpoint.vout")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "batch_outpoint.vout"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "batch_outpoint.vout", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "batch_outpoint.vout"}
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_IndexerService_GetVtxoTree_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetVtxoTree(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_IndexerService_GetVtxoTreeLeaves_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New("batch_outpoint.vout", "batch_outpoint.txid", "txid", "vout"),
	}
)

func request_IndexerService_GetVtxoTreeLeaves_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetVtxoTreeLeavesRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("batch_outpoint.txid")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "batch_outpoint.txid"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "batch_outpoint.txid", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "batch_outpoint.txid"}
	}

	val = pathParams.ByName("batch_outpoint.vout")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "batch_outpoint.vout"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "batch_outpoint.vout", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "batch_outpoint.vout"}
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_IndexerService_GetVtxoTreeLeaves_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetVtxoTreeLeaves(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_IndexerService_GetVtxos_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New(),
	}
)

func request_IndexerService_GetVtxos_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetVtxosRequest
	var metadata gateway.ServerMetadata

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_IndexerService_GetVtxos_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetVtxos(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_IndexerService_GetVtxoChain_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New("outpoint.txid", "outpoint.vout", "txid", "vout"),
	}
)

func request_IndexerService_GetVtxoChain_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetVtxoChainRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("outpoint.txid")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "outpoint.txid"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "outpoint.txid", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "outpoint.txid"}
	}

	val = pathParams.ByName("outpoint.vout")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "outpoint.vout"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "outpoint.vout", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "outpoint.vout"}
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_IndexerService_GetVtxoChain_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetVtxoChain(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

var (
	query_params_IndexerService_GetVirtualTxs_0 = gateway.QueryParameterParseOptions{
		Filter: trie.New("txids"),
	}
)

func request_IndexerService_GetVirtualTxs_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetVirtualTxsRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("txids")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "txids"}
	}

	protoReq.Txids, err = protoconvert.StringSlice(val, ",")
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "txids"}
	}

	if err := req.ParseForm(); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}
	if err := mux.PopulateQueryParameters(&protoReq, req.Form, query_params_IndexerService_GetVirtualTxs_0); err != nil {
		return nil, metadata, gateway.ErrInvalidQueryParameters{Err: err}
	}

	msg, err := client.GetVirtualTxs(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_IndexerService_GetBatchSweepTransactions_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq GetBatchSweepTransactionsRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("batch_outpoint.txid")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "batch_outpoint.txid"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "batch_outpoint.txid", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "batch_outpoint.txid"}
	}

	val = pathParams.ByName("batch_outpoint.vout")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "batch_outpoint.vout"}
	}

	err = protopath.PopulateFieldFromPath(&protoReq, "batch_outpoint.vout", val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "batch_outpoint.vout"}
	}

	msg, err := client.GetBatchSweepTransactions(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_IndexerService_SubscribeForScripts_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq SubscribeForScriptsRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.SubscribeForScripts(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_IndexerService_UnsubscribeForScripts_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (proto.Message, gateway.ServerMetadata, error) {
	var protoReq UnsubscribeForScriptsRequest
	var metadata gateway.ServerMetadata

	if err := marshaler.NewDecoder(req.Body).Decode(&protoReq); err != nil && err != io.EOF {
		return nil, metadata, gateway.ErrMarshal{Err: err, Inbound: true}
	}

	msg, err := client.UnsubscribeForScripts(ctx, &protoReq, grpc.Header(&metadata.HeaderMD), grpc.Trailer(&metadata.TrailerMD))
	return msg, metadata, err

}

func request_IndexerService_GetSubscription_0(ctx context.Context, marshaler gateway.Marshaler, mux *gateway.ServeMux, client IndexerServiceClient, req *http.Request, pathParams gateway.Params) (IndexerService_GetSubscriptionClient, gateway.ServerMetadata, error) {
	var protoReq GetSubscriptionRequest
	var metadata gateway.ServerMetadata

	var (
		val string
		err error
		_   = err
	)

	val = pathParams.ByName("subscription_id")
	if val == "" {
		return nil, metadata, gateway.ErrPathParameterMissing{Name: "subscription_id"}
	}

	protoReq.SubscriptionId, err = protoconvert.String(val)
	if err != nil {
		return nil, metadata, gateway.ErrPathParameterTypeMismatch{Err: err, Name: "subscription_id"}
	}

	stream, err := client.GetSubscription(ctx, &protoReq)
	if err != nil {
		return nil, metadata, err
	}
	header, err := stream.Header()
	if err != nil {
		return nil, metadata, err
	}
	metadata.HeaderMD = header
	return stream, metadata, nil

}

// RegisterIndexerServiceHandlerFromEndpoint is same as RegisterIndexerServiceHandler but
// automatically dials to "endpoint" and closes the connection when "ctx" gets done.
func RegisterIndexerServiceHandlerFromEndpoint(ctx context.Context, mux *gateway.ServeMux, endpoint string, opts []grpc.DialOption) error {
	conn, err := grpc.DialContext(ctx, endpoint, opts...)
	if err != nil {
		return err
	}
	defer func() {
		if err != nil {
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
			return
		}
		go func() {
			<-ctx.Done()
			if cerr := conn.Close(); cerr != nil {
				grpclog.Infof("Failed to close conn to %s: %v", endpoint, cerr)
			}
		}()
	}()

	RegisterIndexerServiceHandler(ctx, mux, conn)
	return nil
}

// RegisterIndexerServiceHandler registers the http handlers for service IndexerService to "mux".
// The handlers forward requests to the grpc endpoint over "conn".
func RegisterIndexerServiceHandler(ctx context.Context, mux *gateway.ServeMux, conn *grpc.ClientConn) {
	RegisterIndexerServiceHandlerClient(ctx, mux, NewIndexerServiceClient(conn))
}

// RegisterIndexerServiceHandlerClient registers the http handlers for service IndexerService
// to "mux". The handlers forward requests to the grpc endpoint over the given implementation of "IndexerServiceClient".
// Note: the gRPC framework executes interceptors within the gRPC handler. If the passed in "IndexerServiceClient"
// doesn't go through the normal gRPC flow (creating a gRPC client etc.) then it will be up to the passed in
// "IndexerServiceClient" to call the correct interceptors.
func RegisterIndexerServiceHandlerClient(ctx context.Context, mux *gateway.ServeMux, client IndexerServiceClient) {

	mux.HandleWithParams("GET", "/v1/commitmentTx/:txid", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetCommitmentTx", gateway.WithHTTPPathPattern("/v1/commitmentTx/{txid}"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetCommitmentTx_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/commitmentTx/:txid/forfeitTxs", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetForfeitTxs", gateway.WithHTTPPathPattern("/v1/commitmentTx/{txid}/forfeitTxs"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetForfeitTxs_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/commitmentTx/:txid/connectors", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetConnectors", gateway.WithHTTPPathPattern("/v1/commitmentTx/{txid}/connectors"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetConnectors_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/batch/:batch_outpoint.txid/:batch_outpoint.vout/tree", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetVtxoTree", gateway.WithHTTPPathPattern("/v1/batch/{batch_outpoint.txid}/{batch_outpoint.vout}/tree"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetVtxoTree_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/batch/:batch_outpoint.txid/:batch_outpoint.vout/tree/leaves", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetVtxoTreeLeaves", gateway.WithHTTPPathPattern("/v1/batch/{batch_outpoint.txid}/{batch_outpoint.vout}/tree/leaves"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetVtxoTreeLeaves_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/vtxos", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetVtxos", gateway.WithHTTPPathPattern("/v1/vtxos"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetVtxos_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/vtxo/:outpoint.txid/:outpoint.vout/chain", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetVtxoChain", gateway.WithHTTPPathPattern("/v1/vtxo/{outpoint.txid}/{outpoint.vout}/chain"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetVtxoChain_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/virtualTx/:txids", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetVirtualTxs", gateway.WithHTTPPathPattern("/v1/virtualTx/{txids}"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetVirtualTxs_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/batch/:batch_outpoint.txid/:batch_outpoint.vout/sweepTxs", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetBatchSweepTransactions", gateway.WithHTTPPathPattern("/v1/batch/{batch_outpoint.txid}/{batch_outpoint.vout}/sweepTxs"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetBatchSweepTransactions_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/script/subscribe", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/SubscribeForScripts", gateway.WithHTTPPathPattern("/v1/script/subscribe"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_SubscribeForScripts_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("POST", "/v1/script/unsubscribe", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/UnsubscribeForScripts", gateway.WithHTTPPathPattern("/v1/script/unsubscribe"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_UnsubscribeForScripts_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		mux.ForwardResponseMessage(annotatedContext, outboundMarshaler, w, req, resp)
	})

	mux.HandleWithParams("GET", "/v1/script/subscription/:subscription_id", func(w http.ResponseWriter, req *http.Request, pathParams gateway.Params) {
		ctx, cancel := context.WithCancel(req.Context())
		defer cancel()
		inboundMarshaler, outboundMarshaler := mux.MarshalerForRequest(req)
		var err error
		var annotatedContext context.Context
		annotatedContext, err = gateway.AnnotateContext(ctx, mux, req, "/indexer.v1.IndexerService/GetSubscription", gateway.WithHTTPPathPattern("/v1/script/subscription/{subscription_id}"))
		if err != nil {
			mux.HTTPError(ctx, outboundMarshaler, w, req, err)
			return
		}

		resp, md, err := request_IndexerService_GetSubscription_0(annotatedContext, inboundMarshaler, mux, client, req, pathParams)
		annotatedContext = gateway.NewServerMetadataContext(annotatedContext, md)
		if err != nil {
			mux.HTTPError(annotatedContext, outboundMarshaler, w, req, err)
			return
		}

		if mux.IsSSE(req) {
			mux.ForwardResponseStreamSSE(annotatedContext, outboundMarshaler, w, req, func() (proto.Message, error) { return resp.Recv() })
			return
		}

		mux.HTTPError(ctx, outboundMarshaler, w, req, gateway.ErrStreamingMethodNotAllowed{
			MethodSupportsWebsocket:       false,
			MethodSupportsSSE:             true,
			MethodSupportsChunkedTransfer: false,
		})

	})

}
